<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rust on 外部記憶</title>
    <link>/tags/rust/</link>
    <description>Recent content in Rust on 外部記憶</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017. All rights reserved.</copyright>
    <lastBuildDate>Sat, 24 Feb 2018 00:00:00 +0900</lastBuildDate>
    <atom:link href="/tags/rust/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Vecの実装 in Rust - Handling Zero-Sized Types</title>
      <link>/post/implementingvecinrust/handling_zero-sized_types/</link>
      <pubDate>Sat, 24 Feb 2018 00:00:00 +0900</pubDate>
      
      <guid>/post/implementingvecinrust/handling_zero-sized_types/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;No page found with path or logical name &#34;post/ImplementingVecInRust/drain&#34;.
&#34;&gt;前回&lt;/a&gt; に引き続き、
&lt;a href=&#34;https://doc.rust-lang.org/nomicon&#34;&gt;The Rustnomicon&lt;/a&gt; の &lt;a href=&#34;https://doc.rust-lang.org/nomicon/vec.html&#34;&gt;Implementing &lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; をやってみる。&lt;/p&gt;

&lt;p&gt;コード全体は &lt;a href=&#34;https://github.com/ordovicia/rustnomicon_vec.git&#34;&gt;GitHub上のリポジトリ&lt;/a&gt; にある。&lt;/p&gt;

&lt;p&gt;rustcのバージョンは以下のとおり。&lt;/p&gt;
$ rustc --version
rustc 1.25.0-nightly (27a046e93 2018-02-18)

&lt;h2 id=&#34;handling-zero-sized-types-https-doc-rust-lang-org-nomicon-vec-zsts-html:6c180c463723d44d0b4f6dffbfe89ab3&#34;&gt;&lt;a href=&#34;https://doc.rust-lang.org/nomicon/vec-zsts.html&#34;&gt;Handling Zero-Sized Types&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;最後に、&lt;a href=&#34;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&#34;&gt;ZST (Zero Sized Type)&lt;/a&gt; に対応する。
これに際して、二点考慮する必要がある。&lt;/p&gt;

&lt;p&gt;まず、&lt;a href=&#34;https://doc.rust-lang.org/nightly/std/heap/trait.Alloc.html&#34;&gt;&lt;code&gt;heap::Alloc&lt;/code&gt;&lt;/a&gt; はZSTを正しく扱えるとは限ず、このtraitを実装する型に依存する。
今回は &lt;a href=&#34;https://doc.rust-lang.org/nightly/std/heap/struct.Heap.html&#34;&gt;&lt;code&gt;heap::Heap&lt;/code&gt;&lt;/a&gt; を用いることがわかっているが、あまりドキュメントもないので実装に依存しないことにする。&lt;/p&gt;

&lt;p&gt;ZSTに対応するため、&lt;code&gt;RawVec&lt;/code&gt; に以下の修正を加える。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;default()&lt;/code&gt; では、キャパシティをはじめから &lt;code&gt;usize::MAX&lt;/code&gt; に設定してしまう &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:6c180c463723d44d0b4f6dffbfe89ab3:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:6c180c463723d44d0b4f6dffbfe89ab3:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;grow()&lt;/code&gt; が呼ばれたら &lt;code&gt;panic!()&lt;/code&gt; する。キャパシティが &lt;code&gt;usize::MAX&lt;/code&gt; なので、&lt;code&gt;grow()&lt;/code&gt; が呼ばれるということはそれを超える要素が格納されようとしていることを意味する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;drop()&lt;/code&gt; ではメモリ解放しない。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;つまり、次のように変更する。&lt;/p&gt;
impl&lt;T&gt; RawVec&lt;T&gt; {
    pub(super) fn default() -&gt; Self {
        // !0 is usize::MAX. This branch should be stripped at compile time.
        let cap = if mem::size_of::&lt;T&gt;() == 0 { !0 } else { 0 };

        RawVec {
            ptr: OwnedPtr::empty(),
            cap: cap,
            alloc: Heap,
        }
    }

    pub(super) fn grow(&amp;mut self) {
        let elem_size = mem::size_of::&lt;T&gt;();

        // since we set the capacity to usize::MAX when elem_size is
        // 0, getting to here necessarily means the Vec is overfull.
        assert!(elem_size != 0, &#34;capacity overflow&#34;);

        let (ptr, new_cap) = if self.cap == 0 {
            (self.alloc.alloc_one::&lt;T&gt;(), 1)
        } else {
            let old_num_bytes = self.cap * elem_size;

            ...
        };

        ...
    }
}

impl&lt;T&gt; Drop for RawVec&lt;T&gt; {
    fn drop(&amp;mut self) {
        let elem_size = mem::size_of::&lt;T&gt;();

        // don&#39;t free zero-sized allocations, as they were never allocated.
        if self.cap == 0 || elem_size == 0 {
            return;
        }

        ...
    }
}

&lt;p&gt;次に考慮する点として、イテレータはこれまでのように &lt;code&gt;ptr.offset()&lt;/code&gt; でポインタを進めていくわけにはいかない。
サイズがゼロなので、 &lt;code&gt;ptr.offset()&lt;/code&gt; は何もしない。
そこで、ポインタを &lt;code&gt;usize&lt;/code&gt; にキャストして整数としてインクリメント・デクリメントしていくことにする。&lt;/p&gt;
impl&lt;T&gt; RawValIter&lt;T&gt; {
    pub(super) unsafe fn new(slice: &amp;[T]) -&gt; Self {
        let start = slice.as_ptr();

        RawValIter {
            start,
            end: if mem::size_of::&lt;T&gt;() == 0 {
                ((start as usize) + slice.len()) as *const _
            } else if slice.is_empty() {
                start
            } else {
                start.offset(slice.len() as isize)
            },
        }
    }
}

impl&lt;T&gt; Iterator for RawValIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None
        } else {
            unsafe {
                let result = ptr::read(self.start);
                self.start = if mem::size_of::&lt;T&gt;() == 0 {
                    (self.start as usize + 1) as *const _
                } else {
                    self.start.offset(1)
                };
                Some(result)
            }
        }
    }

    ...
}

impl&lt;T&gt; DoubleEndedIterator for RawValIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None
        } else {
            unsafe {
                self.end = if mem::size_of::&lt;T&gt;() == 0 {
                    (self.end as usize - 1) as *const _
                } else {
                    self.end.offset(-1)
                };
                Some(ptr::read(self.end))
            }
        }
    }
}

&lt;p&gt;最後に、&lt;code&gt;Iterator::size_hint()&lt;/code&gt; を修正する。
要素のサイズでイテレータの差を割るので、ZSTではゼロで割ることになってしまう。&lt;/p&gt;
impl&lt;T&gt; Iterator for RawValIter&lt;T&gt; {
    ...

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        let elem_size = mem::size_of::&lt;T&gt;();
        let len = (self.end as usize - self.start as usize)
                  / if elem_size == 0 { 1 } else { elem_size };
        (len, Some(len))
    }
}
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:6c180c463723d44d0b4f6dffbfe89ab3:1&#34;&gt;Rustnomiconでも &lt;a href=&#34;https://doc.rust-lang.org/nightly/src/alloc/raw_vec.rs.html#53&#34;&gt;標準ライブラリの &lt;code&gt;RawVec&lt;/code&gt;&lt;/a&gt; でも、&lt;code&gt;usize::MAX&lt;/code&gt; を表すのに &lt;code&gt;!0&lt;/code&gt; としているが、はじめから &lt;code&gt;usize::MAX&lt;/code&gt; にすればいいのでは&amp;hellip;&amp;hellip;？
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:6c180c463723d44d0b4f6dffbfe89ab3:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Vecの実装 in Rust - Drain</title>
      <link>/post/implementingvecinrust/drain/</link>
      <pubDate>Fri, 23 Feb 2018 00:00:01 +0900</pubDate>
      
      <guid>/post/implementingvecinrust/drain/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;No page found with path or logical name &#34;post/ImplementingVecInRust/raw_vec&#34;.
&#34;&gt;前回&lt;/a&gt; に引き続き、
&lt;a href=&#34;https://doc.rust-lang.org/nomicon&#34;&gt;The Rustnomicon&lt;/a&gt; の &lt;a href=&#34;https://doc.rust-lang.org/nomicon/vec.html&#34;&gt;Implementing &lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; をやってみる。&lt;/p&gt;

&lt;p&gt;コード全体は &lt;a href=&#34;https://github.com/ordovicia/rustnomicon_vec.git&#34;&gt;GitHub上のリポジトリ&lt;/a&gt; にある。&lt;/p&gt;

&lt;p&gt;rustcのバージョンは以下のとおり。&lt;/p&gt;
$ rustc --version
rustc 1.25.0-nightly (27a046e93 2018-02-18)

&lt;h2 id=&#34;drain-https-doc-rust-lang-org-nomicon-vec-drain-html:1a3000761c0962c281e57308b055a5dd&#34;&gt;&lt;a href=&#34;https://doc.rust-lang.org/nomicon/vec-drain.html&#34;&gt;Drain&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;IntoIter&lt;/code&gt; に続く有用なイテレータとして、&lt;code&gt;Drain&lt;/code&gt; を実装する。
&lt;code&gt;Drain&lt;/code&gt; はおよそ &lt;code&gt;IntoIter&lt;/code&gt; と同じだが、&lt;code&gt;Vec&lt;/code&gt; の要素を消費せず借用して取り出し、メモリ領域の管理は移さない。
&lt;a href=&#34;https://doc.rust-lang.org/nightly/std/vec/struct.Drain.html&#34;&gt;標準ライブラリの &lt;code&gt;vec::Drain&lt;/code&gt;&lt;/a&gt; は取り出す要素をrangeで指定でき、一部だけ取り出すこともできる。
今回は簡単に、開始位置だけ指定でき、そこから最後の要素までを取り出すバージョンを書いてみる &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1a3000761c0962c281e57308b055a5dd:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1a3000761c0962c281e57308b055a5dd:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;まず、&lt;code&gt;Drain&lt;/code&gt; 構造体の定義を考える。
&lt;code&gt;IntoIter&lt;/code&gt; と同じく、&lt;code&gt;Iterator&lt;/code&gt; と &lt;code&gt;DoubleEndedIterator&lt;/code&gt; を &lt;code&gt;Drain&lt;/code&gt; に実装したいので、前方・後方イテレータを用いる実装がよさそうだ。
そうすると、&lt;code&gt;IntoIter&lt;/code&gt; の実装とかぶる部分がでてくるので、この部分を切り出し抽象的なイテレータ構造を定義できそうだと考える。&lt;/p&gt;
pub(super) struct RawValIter&lt;T&gt; {
    start: *const T,
    end: *const T,
}

impl&lt;T&gt; RawValIter&lt;T&gt; {
    pub(super) unsafe fn new(slice: &amp;[T]) -&gt; Self {
        let start = slice.as_ptr();

        RawValIter {
            start,
            end: if slice.len() == 0 {
                start
            } else {
                start.offset(slice.len() as isize)
            },
        }
    }
}

&lt;p&gt;前方・後方イテレータをもつ抽象的なイテレータ構造ができた。
&lt;code&gt;new()&lt;/code&gt; がunsafeなのは、スライスから生ポインタを取り出すことでlifetimeの情報が失われるためである。
あとで &lt;code&gt;RawValIter&lt;/code&gt; を &lt;code&gt;RawVec&lt;/code&gt; と同じ構造体に入れるので、lifetime情報を付与したままにはできない。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RawValIter&lt;/code&gt; に実装する &lt;code&gt;Iterator&lt;/code&gt; と &lt;code&gt;DoubleEndedIterator&lt;/code&gt; は、 &lt;code&gt;IntoIter&lt;/code&gt; に定義したものと同様に定義しておく。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RawValIter&lt;/code&gt; を用いて、&lt;code&gt;IntoIter&lt;/code&gt; および &lt;code&gt;Vec::into_iter()&lt;/code&gt; は次のように修正できる。
&lt;code&gt;Iterator&lt;/code&gt;, &lt;code&gt;DoubleEndedIterator&lt;/code&gt; の実装は、内部に持つ &lt;code&gt;RawValIter&lt;/code&gt; の実装に委任できる。&lt;/p&gt;
pub struct IntoIter&lt;T&gt; {
    _buf: RawVec&lt;T&gt;,
    iter: RawValIter&lt;T&gt;,
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;

    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.iter.next()
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        self.iter.size_hint()
    }
}

impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.iter.next_back()
    }
}

impl&lt;T&gt; IntoIter&lt;T&gt; {
    pub(super) fn new(buf: RawVec&lt;T&gt;, iter: RawValIter&lt;T&gt;) -&gt; Self {
        IntoIter { _buf: buf, iter }
    }
}
impl&lt;T&gt; for Vec&lt;T&gt; {
    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        unsafe {
            let iter = RawValIter::new(&amp;self);

            let buf = ptr::read(&amp;self.buf);
            mem::forget(self);

            IntoIter::new(buf, iter)
        }
    }
}

&lt;p&gt;&lt;code&gt;Drain&lt;/code&gt; を実装する。
&lt;code&gt;Vec&lt;/code&gt; から要素を借用するのでlifetime引数をとるが、定義には現れないので &lt;code&gt;PhantomData&lt;/code&gt; を用いる。&lt;/p&gt;
use std::marker::PhantomData;

pub struct Drain&lt;&#39;a, T: &#39;a&gt; {
    // Need to bound the lifetime here, so we do it with `&amp;&#39;a mut Vec&lt;T&gt;`
    // because that&#39;s semantically what we contain. We&#39;re &#34;just&#34; calling
    // `pop()` and `remove(0)`.
    _vec: PhantomData&lt;&amp;&#39;a mut Vec&lt;T&gt;&gt;,
    iter: RawValIter&lt;T&gt;,
}

impl&lt;&#39;a, T&gt; Drop for Drain&lt;&#39;a, T&gt; {
    fn drop(&amp;mut self) {
        for _ in &amp;mut self.iter {}
    }
}

impl&lt;&#39;a, T&gt; Drain&lt;&#39;a, T&gt; {
    pub(super) fn new(iter: RawValIter&lt;T&gt;) -&gt; Self {
        Drain {
            _vec: PhantomData,
            iter,
        }
    }
}

&lt;p&gt;&lt;code&gt;Vec::drain()&lt;/code&gt; は次のように書ける。&lt;/p&gt;
impl&lt;T&gt; Vec&lt;T&gt; {
    pub fn drain(&amp;mut self, start: usize) -&gt; Drain&lt;T&gt; {
        assert!(start &lt; len);

        unsafe {
            let iter = RawValIter::new(&amp;self[start..]);
            self.len = start;
            Drain::new(iter)
        }
    }
}

&lt;p&gt;簡単なテストを書き動作確認する。&lt;/p&gt;
#![feature(crate_in_paths)] // in lib.rs

#[cfg(test)]
mod tests {
    use crate::vec::Vec;

    #[test]
    fn drain() {
        let mut v = Vec::default();
        v.push(0);
        v.push(1);

        {
            let mut drain = v.drain(1);
            assert_eq!(drain.next(), Some(1));
            assert_eq!(drain.next(), None);
        }

        assert_eq!(v.len(), 1);

        let mut iter = v.into_iter();
        assert_eq!(iter.next(), Some(0));
        assert_eq!(iter.next(), None);
    }
}
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1a3000761c0962c281e57308b055a5dd:1&#34;&gt;Rustnomiconでは全範囲を取り出すバージョンを書いているが、それではあまりに単純すぎる。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1a3000761c0962c281e57308b055a5dd:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Vecの実装 in Rust - RawVec</title>
      <link>/post/implementingvecinrust/raw_vec/</link>
      <pubDate>Fri, 23 Feb 2018 00:00:00 +0900</pubDate>
      
      <guid>/post/implementingvecinrust/raw_vec/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;No page found with path or logical name &#34;post/ImplementingVecInRust/into_iter&#34;.
&#34;&gt;前回&lt;/a&gt; に引き続き、
&lt;a href=&#34;https://doc.rust-lang.org/nomicon&#34;&gt;The Rustnomicon&lt;/a&gt; の &lt;a href=&#34;https://doc.rust-lang.org/nomicon/vec.html&#34;&gt;Implementing &lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; をやってみる。&lt;/p&gt;

&lt;p&gt;コード全体は &lt;a href=&#34;https://github.com/ordovicia/rustnomicon_vec.git&#34;&gt;GitHub上のリポジトリ&lt;/a&gt; にある。&lt;/p&gt;

&lt;p&gt;rustcのバージョンは以下のとおり。&lt;/p&gt;
$ rustc --version
rustc 1.25.0-nightly (27a046e93 2018-02-18)

&lt;h2 id=&#34;rawvec-https-doc-rust-lang-org-nomicon-vec-raw-html:6caff5f9ed3448f059ff5d0888564fc8&#34;&gt;&lt;a href=&#34;https://doc.rust-lang.org/nomicon/vec-raw.html&#34;&gt;RawVec&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;前回実装した &lt;code&gt;IntoIter&lt;/code&gt; をよく見ると、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;OwnedPtr&lt;/code&gt; と &lt;code&gt;cap&lt;/code&gt;, &lt;code&gt;alloc&lt;/code&gt; による、確保したメモリ領域の管理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Drop&lt;/code&gt; の実装におけるメモリ解放処理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;が &lt;code&gt;Vec&lt;/code&gt; とかぶっていることが分かる。
こんなとき、重複部分を切り出して抽象化したくなるのが人の情である。&lt;/p&gt;

&lt;p&gt;そこで、メモリ管理処理を &lt;code&gt;RawVec&lt;/code&gt; という構造体に切り出してみる。
標準ライブラリでも &lt;a href=&#34;https://doc.rust-lang.org/nightly/alloc/raw_vec/struct.RawVec.html&#34;&gt;同様の設計&lt;/a&gt;  を取り、
&lt;a href=&#34;https://doc.rust-lang.org/nightly/src/alloc/vec.rs.html#302-305&#34;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://doc.rust-lang.org/nightly/src/alloc/vec_deque.rs.html#57-66&#34;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; などで使われている。&lt;/p&gt;
use std::heap::{Alloc, Heap};
use std::mem;

pub(super) struct RawVec&lt;T&gt; {
    pub(super) ptr: OwnedPtr&lt;T&gt;,
    pub(super) cap: usize,
    alloc: Heap,
}

impl&lt;T&gt; Drop for RawVec&lt;T&gt; {
    fn drop(&amp;mut self) {
        if self.cap == 0 {
            return;
        }

        unsafe {
            if self.cap == 1 {
                self.alloc.dealloc_one(self.ptr.as_non_null());
            } else {
                let e = self.alloc.dealloc_array(self.ptr.as_non_null(), self.cap);
                if let Err(e) = e {
                    self.alloc.oom(e);
                }
            }
        }
    }
}

impl&lt;T&gt; RawVec&lt;T&gt; {
    pub(super) fn default() -&gt; Self {
        assert!(mem::size_of::&lt;T&gt;() != 0, &#34;We&#39;re not ready to handle ZSTs&#34;);

        RawVec {
            ptr: OwnedPtr::empty(),
            cap: 0,
            alloc: Heap,
        }
    }

    pub(super) fn grow(&amp;mut self) {
        // unchanged from Vec
    }
}

&lt;p&gt;&lt;code&gt;Drop&lt;/code&gt; の実装でメモリ領域を解放する。
ただし、&lt;code&gt;RawVec&lt;/code&gt; は「要素」という概念を持たないので、要素の解放は &lt;code&gt;Vec&lt;/code&gt;, &lt;code&gt;IntoIter&lt;/code&gt; で処理する必要がある。&lt;/p&gt;

&lt;p&gt;この &lt;code&gt;RawVec&lt;/code&gt; を使うよう、&lt;code&gt;Vec&lt;/code&gt;, &lt;code&gt;IntoIter&lt;/code&gt; を修正していく。
まず &lt;code&gt;impl Drop for Vec&lt;/code&gt; は、要素ごとにdropしたあとはメモリ領域の解放を &lt;code&gt;RawVec&lt;/code&gt; に任せられる。&lt;/p&gt;
pub struct Vec&lt;T&gt; {
    buf: RawVec&lt;T&gt;,
    len: usize,
}

impl&lt;T&gt; Drop for Vec&lt;T&gt; {
    fn drop(&amp;mut self) {
        if mem::needs_drop::&lt;T&gt;() {
            while let Some(_) = self.pop() {}
        }

        // deallocation is handled by RawVec
    }
}

&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; の他の部分については、&lt;code&gt;RawVec&lt;/code&gt; からポインタを取り出す &lt;code&gt;ptr()&lt;/code&gt; メソッドと、キャパシティを得る &lt;code&gt;capacity()&lt;/code&gt; を追加し使うようにした以外はほぼ変わらない。
&lt;code&gt;into_iter()&lt;/code&gt; では、&lt;code&gt;RawVec&lt;/code&gt; が &lt;code&gt;Copy&lt;/code&gt; でないため &lt;code&gt;ptr::read()&lt;/code&gt; によりメモリ領域を取り出す必要がある。&lt;/p&gt;
impl&lt;T&gt; Vec&lt;T&gt; {
    /// Returns capacity.
    pub fn capacity(&amp;self) -&gt; usize {
        self.buf.cap
    }

    /// Creates an [`IntoIter`] instance from self.
    ///
    /// [`IntoIter`]: ../into_iter/struct.IntoIter.html
    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        // need to use ptr::read to unsafely move the buf out since it&#39;s
        // not Copy, and Vec implements Drop (so we can&#39;t destructure it).
        let buf = unsafe { ptr::read(&amp;self.buf) };
        let cap = self.capacity();
        let len = self.len;

        mem::forget(self);

        let start = buf.ptr.as_ptr();

        IntoIter::new(
            buf,
            start,
            if cap == 0 {
                // can&#39;t offset off this pointer, it&#39;s not allocated!
                start
            } else {
                unsafe { start.offset(len as isize) }
            },
        )
    }

    fn ptr(&amp;self) -&gt; *mut T {
        self.buf.ptr.as_ptr()
    }
}

&lt;p&gt;次に、&lt;code&gt;IntoIter&lt;/code&gt; を &lt;code&gt;RawVec&lt;/code&gt; を使って書き直す。
&lt;code&gt;Vec&lt;/code&gt; と同様に、&lt;code&gt;impl Drop for IntoIter&lt;/code&gt; は要素をdropしたあとは &lt;code&gt;RawVec&lt;/code&gt; に任せる。&lt;/p&gt;
pub struct IntoIter&lt;T&gt; {
    _buf: RawVec&lt;T&gt;, // we don&#39;t actually care abount this. Just need it to live.
    start: *const T,
    end: *const T,
}

impl&lt;T&gt; Drop for IntoIter&lt;T&gt; {
    fn drop(&amp;mut self) {
        if mem::needs_drop::&lt;T&gt;() {
            for _ in &amp;mut *self {}
        }

        // deallocation is handled by RawVec
    }
}

impl&lt;T&gt; IntoIter&lt;T&gt; {
    pub(super) fn new(buf: RawVec&lt;T&gt;, start: *const T, end: *const T) -&gt; Self {
        IntoIter {
            _buf: buf,
            start,
            end,
        }
    }
}
</description>
    </item>
    
    <item>
      <title>Vecの実装 in Rust - IntoIter</title>
      <link>/post/implementingvecinrust/into_iter/</link>
      <pubDate>Thu, 22 Feb 2018 00:00:00 +0900</pubDate>
      
      <guid>/post/implementingvecinrust/into_iter/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;No page found with path or logical name &#34;post/ImplementingVecInRust/insert_and_remove&#34;.
&#34;&gt;前回&lt;/a&gt; に引き続き、
&lt;a href=&#34;https://doc.rust-lang.org/nomicon&#34;&gt;The Rustnomicon&lt;/a&gt; の &lt;a href=&#34;https://doc.rust-lang.org/nomicon/vec.html&#34;&gt;Implementing &lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; をやってみる。&lt;/p&gt;

&lt;p&gt;コード全体は &lt;a href=&#34;https://github.com/ordovicia/rustnomicon_vec.git&#34;&gt;GitHub上のリポジトリ&lt;/a&gt; にある。&lt;/p&gt;

&lt;p&gt;rustcのバージョンは以下のとおり。&lt;/p&gt;
$ rustc --version
rustc 1.25.0-nightly (27a046e93 2018-02-18)

&lt;h2 id=&#34;intoiter-https-doc-rust-lang-org-nomicon-vec-into-iter-html:31c8e7c8658a9d77d89ee5160d15fa2e&#34;&gt;&lt;a href=&#34;https://doc.rust-lang.org/nomicon/vec-into-iter.html&#34;&gt;IntoIter&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;スライスへのderef.を実装したことで、イテレータに関するかなりのメソッドが定義できた。
しかし、標準ライブラリの &lt;code&gt;Vec&lt;/code&gt; は、他にも有用な種類のイテレータも実装している。
&lt;code&gt;into_iter()&lt;/code&gt; と &lt;code&gt;drain()&lt;/code&gt; である。
この記事ではまず &lt;code&gt;into_iter()&lt;/code&gt; を扱う。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;into_iter()&lt;/code&gt; が返す &lt;code&gt;IntoIter&lt;/code&gt; は、スライスと違い要素を所有する。
従って &lt;code&gt;Vec&lt;/code&gt; が持っているメモリ領域の管理を &lt;code&gt;IntoIter&lt;/code&gt; に移す必要がある。&lt;/p&gt;

&lt;p&gt;また、標準ライブラリの &lt;a href=&#34;https://doc.rust-lang.org/nightly/std/iter/trait.IntoIterator.html&#34;&gt;&lt;code&gt;vec::IntoIter&lt;/code&gt;&lt;/a&gt; は、
&lt;a href=&#34;https://doc.rust-lang.org/nightly/std/iter/trait.DoubleEndedIterator.html&#34;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; も実装している。
&lt;code&gt;DoubleEndedIterator&lt;/code&gt; を実装するには、配列の最後の要素を消費して取り出す &lt;code&gt;next_back()&lt;/code&gt; を提供しなければならない。
こんなときよく使われる方法が、配列の最初と最後（のひとつ後）を指すポインタをそれぞれ前方・後方イテレータとして用意する方法である。&lt;/p&gt;
          S  E
[X, X, X, O, X, X, X]

&lt;p&gt;&lt;code&gt;X&lt;/code&gt; はすでに消費した要素、&lt;code&gt;O&lt;/code&gt; は未消費の要素を表す。
&lt;code&gt;S (start)&lt;/code&gt;, &lt;code&gt;E (end)&lt;/code&gt; という二つのポインタで前方・後方イテレータを表す。&lt;/p&gt;

&lt;p&gt;そこで、今回実装する &lt;code&gt;IntoIter&lt;/code&gt; の定義は以下のようになる。
&lt;code&gt;buf&lt;/code&gt;, &lt;code&gt;cap&lt;/code&gt;, &lt;code&gt;alloc&lt;/code&gt; が &lt;code&gt;Vec&lt;/code&gt; から受け継いだメモリ領域に関するものである。&lt;/p&gt;
use std::heap::Heap;

pub struct IntoIter&lt;T&gt; {
    pub(super) buf: OwnedPtr&lt;T&gt;,
    pub(super) cap: usize,
    pub(super) start: *const T,
    pub(super) end: *const T,
    pub(super) alloc: Heap,
}

&lt;p&gt;そして &lt;code&gt;Vec::into_iter()&lt;/code&gt; は次のように実装できる。
気をつけないといけないのが、&lt;code&gt;Vec&lt;/code&gt; が確保したメモリ領域を管理する責任は &lt;code&gt;IntoIter&lt;/code&gt; に移ることである。
従って、&lt;code&gt;Vec::drop()&lt;/code&gt; が呼ばれないように &lt;a href=&#34;https://doc.rust-lang.org/nightly/std/mem/fn.forget.html&#34;&gt;&lt;code&gt;mem::forget()&lt;/code&gt;&lt;/a&gt; を呼ぶ必要がある。&lt;/p&gt;
impl&lt;T&gt; for Vec&lt;T&gt; {
    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        let Vec {
            ptr: buf,
            cap,
            len,
            alloc,
        } = self;

        // Make sure not to drop Vec since that will free the buffer
        mem::forget(self);

        IntoIter {
            buf,
            cap,
            start: buf.as_ptr(),
            end: if cap == 0 {
                // can&#39;t offset off this pointer, it&#39;s not allocated!
                buf.as_ptr()
            } else {
                unsafe { buf.as_ptr().offset(len as isize) }
            },
            alloc,
        }
    }
}

&lt;p&gt;&lt;code&gt;IntoIter&lt;/code&gt; に、イテレータの機能を実装していく。
まずは &lt;code&gt;Iterator&lt;/code&gt; traitを忘れてはいけない。
&lt;code&gt;Iterator&lt;/code&gt; traitの実装に最低限必要なのは、&lt;a href=&#34;https://doc.rust-lang.org/nightly/std/iter/trait.Iterator.html#tymethod.next&#34;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; である。
前方イテレータが指す要素を取り出し、イテレータを進める。
すでに全要素が消費されていたら（&lt;code&gt;start == end&lt;/code&gt; のとき）&lt;code&gt;None&lt;/code&gt; を返す。&lt;/p&gt;

&lt;p&gt;必須ではないが実装しておくことが望ましいメソッドとして、&lt;a href=&#34;https://doc.rust-lang.org/nightly/std/iter/trait.Iterator.html#method.size_hint&#34;&gt;&lt;code&gt;size_hint()&lt;/code&gt;&lt;/a&gt; がある。
イテレータが管理している要素の個数を、最小値と最大値（存在すれば）のペアで返す関数で、正しく実装すれば他の関数が最適化のヒントに用いることができる。
今回は &lt;code&gt;start&lt;/code&gt; と &lt;code&gt;end&lt;/code&gt; で挟まれた部分を数えれば、要素数が正しく求まる。&lt;/p&gt;
use std::ptr;
use std::mem;
use std::heap::{Alloc, Heap};

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;

    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None
        } else {
            unsafe {
                let result = ptr::read(self.start);
                self.start = self.start.offset(1);
                Some(result)
            }
        }
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        let len = (self.end as usize - self.start as usize) / mem::size_of::&lt;T&gt;();
        (len, Some(len))
    }
}

&lt;p&gt;次に &lt;code&gt;DoubleEndedIterator&lt;/code&gt; traitを実装する。
必須のメソッドは、後方イテレータ（のひとつ前）が指す要素を取り出しイテレータを（後ろに）進める
&lt;a href=&#34;https://doc.rust-lang.org/nightly/std/iter/trait.DoubleEndedIterator.html#tymethod.next_back&#34;&gt;&lt;code&gt;next_back()&lt;/code&gt;&lt;/a&gt; のみである。
&lt;code&gt;Iterator::next()&lt;/code&gt; と同様に実装すればよい。
デフォルト実装が提供される他のメソッドを自前で実装する必要はなさそうだ。&lt;/p&gt;
impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None
        } else {
            unsafe {
                self.end = self.end.offset(-1);
                Some(ptr::read(self.end))
            }
        }
    }
}

&lt;p&gt;忘れてはならないのが、&lt;code&gt;Drop&lt;/code&gt; を実装し、&lt;code&gt;Vec&lt;/code&gt; から管理を移したメモリ領域を解放することである。
&lt;code&gt;Vec&lt;/code&gt; のときは &lt;code&gt;pop()&lt;/code&gt; によって要素ごとのdropをおこなっていたが、イテレータの場合、すべて走査することで代えることができる。&lt;/p&gt;
impl&lt;T&gt; Drop for IntoIter&lt;T&gt; {
    fn drop(&amp;mut self) {
        if self.cap == 0 {
            return;
        }

        if mem::needs_drop::&lt;T&gt;() {
            for _ in &amp;mut *self {}
        }

        unsafe {
            if self.cap == 1 {
                self.alloc.dealloc_one(self.buf.as_non_null());
            } else {
                let e = self.alloc.dealloc_array(self.buf.as_non_null(), self.cap);
                if let Err(e) = e {
                    self.alloc.oom(e);
                }
            }
        }
    }
}
</description>
    </item>
    
    <item>
      <title>Vecの実装 in Rust - Insert &amp; Remove</title>
      <link>/post/implementingvecinrust/insert_and_remove/</link>
      <pubDate>Wed, 21 Feb 2018 00:00:03 +0900</pubDate>
      
      <guid>/post/implementingvecinrust/insert_and_remove/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;No page found with path or logical name &#34;post/ImplementingVecInRust/deref&#34;.
&#34;&gt;前回&lt;/a&gt; に引き続き、
&lt;a href=&#34;https://doc.rust-lang.org/nomicon&#34;&gt;The Rustnomicon&lt;/a&gt; の &lt;a href=&#34;https://doc.rust-lang.org/nomicon/vec.html&#34;&gt;Implementing &lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; をやってみる。&lt;/p&gt;

&lt;p&gt;コード全体は &lt;a href=&#34;https://github.com/ordovicia/rustnomicon_vec.git&#34;&gt;GitHub上のリポジトリ&lt;/a&gt; にある。&lt;/p&gt;

&lt;p&gt;rustcのバージョンは以下のとおり。&lt;/p&gt;
$ rustc --version
rustc 1.25.0-nightly (27a046e93 2018-02-18)

&lt;h2 id=&#34;insert-and-remove-https-doc-rust-lang-org-nomicon-vec-insert-remove-html:6fc5d28cf2f4e8837bab8804a7d6fe7c&#34;&gt;&lt;a href=&#34;https://doc.rust-lang.org/nomicon/vec-insert-remove.html&#34;&gt;Insert and Remove&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;スライスへのderef.で提供されないメソッドとして、例えば &lt;code&gt;insert()&lt;/code&gt; や &lt;code&gt;remove()&lt;/code&gt; がある。
これらを追加する。&lt;/p&gt;

&lt;p&gt;まず &lt;code&gt;Vec::insert()&lt;/code&gt; である。
この関数は、要素を指定したインデックスに挿入する。
指定したインデックスと、それより右にあった要素は右にシフトされる。
インデックスが &lt;code&gt;len&lt;/code&gt; を越えていたら &lt;code&gt;panic!()&lt;/code&gt; する。&lt;/p&gt;

&lt;p&gt;実装は以下のようになる。
インデックスの範囲チェック後、確保したメモリが足りなければ再確保する。
&lt;code&gt;index &amp;lt; self.len&lt;/code&gt; のとき（つまり、&lt;code&gt;index == self.len&lt;/code&gt; でないとき）は、もともとあった要素のシフトが必要になる。
この操作は &lt;a href=&#34;https://doc.rust-lang.org/nightly/std/ptr/fn.copy.html&#34;&gt;&lt;code&gt;ptr::copy()&lt;/code&gt;&lt;/a&gt; でできる。
&lt;code&gt;ptr::copy()&lt;/code&gt; はC言語でいう &lt;code&gt;memmove&lt;/code&gt; で、アドレスからアドレスへ指定要素だけその中身をコピーする。
コピー元・先で領域がオーバーラップしていても正しく扱ってくれる。
もともとあった要素をシフトした後は、挿入する要素をメモリに書き込み、&lt;code&gt;len&lt;/code&gt; をインクリメントして終了である。&lt;/p&gt;
impl&lt;T&gt; Vec&lt;T&gt; {
    pub fn insert(&amp;mut self, index: usize, elem: T) {
        assert!(index &lt;= self.len, &#34;index out of bounds&#34;);

        if self.len == self.cap {
            self.grow();
        }

        unsafe {
            if index &lt; self.len {
                // ptr::copy(src, dest, len): &#34;copy from source to dest len elems&#34;
                ptr::copy(
                    self.ptr.as_ptr().offset(index as isize),
                    self.ptr.as_ptr().offset(index as isize + 1),
                    self.len - index,
                );
            }

            ptr::write(self.ptr.as_ptr().offset(index as isize), elem);
        }

        self.len += 1;
    }

&lt;p&gt;次に &lt;code&gt;Vec::remove()&lt;/code&gt; を実装する。
&lt;code&gt;insert()&lt;/code&gt; とは逆に、指定したインデックスの要素を削除し返す。
もともとあった要素は左にシフトされる。
&lt;code&gt;insert()&lt;/code&gt; と同じように、素直に実装すればよい。&lt;/p&gt;
impl&lt;T&gt; Vec&lt;T&gt; {
    pub fn remove(&amp;mut self, index: usize) -&gt; T {
        assert!(index &lt; self.len, &#34;index out of bounds&#34;);

        self.len -= 1;

        unsafe {
            let result = ptr::read(self.ptr.as_ptr().offset(index as isize));
            ptr::copy(
                self.ptr.as_ptr().offset(index as isize + 1),
                self.ptr.as_ptr().offset(index as isize),
                self.len - index,
            );
            result
        }
    }
}
</description>
    </item>
    
    <item>
      <title>Vecの実装 in Rust - Deref</title>
      <link>/post/implementingvecinrust/deref/</link>
      <pubDate>Wed, 21 Feb 2018 00:00:02 +0900</pubDate>
      
      <guid>/post/implementingvecinrust/deref/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;No page found with path or logical name &#34;post/ImplementingVecInRust/deallocating&#34;.
&#34;&gt;前回&lt;/a&gt; に引き続き、
&lt;a href=&#34;https://doc.rust-lang.org/nomicon&#34;&gt;The Rustnomicon&lt;/a&gt; の &lt;a href=&#34;https://doc.rust-lang.org/nomicon/vec.html&#34;&gt;Implementing &lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; をやってみる。&lt;/p&gt;

&lt;p&gt;コード全体は &lt;a href=&#34;https://github.com/ordovicia/rustnomicon_vec.git&#34;&gt;GitHub上のリポジトリ&lt;/a&gt; にある。&lt;/p&gt;

&lt;p&gt;rustcのバージョンは以下のとおり。&lt;/p&gt;
$ rustc --version
rustc 1.25.0-nightly (27a046e93 2018-02-18)

&lt;h2 id=&#34;deref-https-doc-rust-lang-org-nomicon-vec-deref-html:88ca6c8a2288f56ce93994ebd0001e7c&#34;&gt;&lt;a href=&#34;https://doc.rust-lang.org/nomicon/vec-deref.html&#34;&gt;Deref&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/nightly/std/vec/struct.Vec.html&#34;&gt;標準ライブラリのドキュメント&lt;/a&gt; を見ると、
&lt;code&gt;Vec&lt;/code&gt; に適用できるかなりのメソッドはスライスへのderef.を経由して呼べることが分かる。
&lt;code&gt;Vec&lt;/code&gt; の中身は同じ型を集めた配列なので、スライスへderef.するのは自然である。&lt;/p&gt;

&lt;p&gt;そこで、&lt;code&gt;Deref&amp;lt;Target = [T]&amp;gt; for Vec&amp;lt;T&amp;gt;&lt;/code&gt; を実装する。
簡単で、&lt;a href=&#34;https://doc.rust-lang.org/nightly/alloc/slice/fn.from_raw_parts.html&#34;&gt;&lt;code&gt;slice::from_raw_parts()&lt;/code&gt;&lt;/a&gt; を呼ぶだけである。
はじめのアドレスと要素数を渡すとスライスを作ってくれる。
要素数が0のときも正しく動作するようだ。&lt;/p&gt;
use std::ops::Deref;

impl&lt;T&gt; Deref for Vec&lt;T&gt; {
    type Target = [T];

    fn deref(&amp;self) -&gt; &amp;[T] {
        unsafe { ::std::slice::from_raw_parts(self.ptr.as_ptr(), self.len) }
    }
}

&lt;p&gt;&lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; にderef.する &lt;code&gt;DerefMut&lt;/code&gt; 版もつくっておく。
今度は &lt;a href=&#34;https://doc.rust-lang.org/nightly/alloc/slice/fn.from_raw_parts_mut.html&#34;&gt;&lt;code&gt;slice::from_raw_parts_mut()&lt;/code&gt;&lt;/a&gt; を呼ぶ。
&lt;code&gt;DerefMut: Deref&lt;/code&gt; なので、&lt;code&gt;Target&lt;/code&gt; の指定は必要ない。&lt;/p&gt;
use std::ops::{Deref, DerefMut};

impl&lt;T&gt; DerefMut for Vec&lt;T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut [T] {
        unsafe { ::std::slice::from_raw_parts_mut(self.ptr.as_ptr(), self.len) }
    }
}
</description>
    </item>
    
    <item>
      <title>Vecの実装 in Rust - メモリ解放</title>
      <link>/post/implementingvecinrust/deallocating/</link>
      <pubDate>Wed, 21 Feb 2018 00:00:01 +0900</pubDate>
      
      <guid>/post/implementingvecinrust/deallocating/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;No page found with path or logical name &#34;post/ImplementingVecInRust/push_and_pop&#34;.
&#34;&gt;前回&lt;/a&gt; に引き続き、
&lt;a href=&#34;https://doc.rust-lang.org/nomicon&#34;&gt;The Rustnomicon&lt;/a&gt; の &lt;a href=&#34;https://doc.rust-lang.org/nomicon/vec.html&#34;&gt;Implementing &lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; をやってみる。&lt;/p&gt;

&lt;p&gt;コード全体は &lt;a href=&#34;https://github.com/ordovicia/rustnomicon_vec.git&#34;&gt;GitHub上のリポジトリ&lt;/a&gt; にある。&lt;/p&gt;

&lt;p&gt;rustcのバージョンは以下のとおり。&lt;/p&gt;
$ rustc --version
rustc 1.25.0-nightly (27a046e93 2018-02-18)

&lt;h2 id=&#34;deallocating-https-doc-rust-lang-org-nomicon-vec-dealloc-html:2de0bf3ea219adede37cfcca051487ab&#34;&gt;&lt;a href=&#34;https://doc.rust-lang.org/nomicon/vec-dealloc.html&#34;&gt;Deallocating&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;確保したメモリは使わなくなったら解放しなくてはいけない。
&lt;code&gt;Drop for Vec&lt;/code&gt; を実装し、その中で解放処理を書くことにする。
ここでも新しい &lt;a href=&#34;https://github.com/rust-lang/rfcs/pull/1398&#34;&gt;メモリアロケータAPI&lt;/a&gt; を使う。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;self.cap == 0&lt;/code&gt; のときはメモリ確保していないので、解放もしなくてよい。
&lt;code&gt;self.cap == 1&lt;/code&gt; のときは、&lt;code&gt;pop()&lt;/code&gt; することで要素をdropし、
&lt;a href=&#34;https://doc.rust-lang.org/nightly/std/heap/trait.Alloc.html#method.dealloc_one&#34;&gt;&lt;code&gt;Alloc::dealloc_one&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt; を使う。
それ以外の場合は、すべての要素を順に &lt;code&gt;pop()&lt;/code&gt; することでdropし、
&lt;a href=&#34;https://doc.rust-lang.org/nightly/std/heap/trait.Alloc.html#method.dealloc_array&#34;&gt;&lt;code&gt;Alloc::dealloc_array&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt; を呼ぶ。&lt;/p&gt;
impl&lt;T&gt; Drop for Vec&lt;T&gt; {
    fn drop(&amp;mut self) {
        if self.cap == 0 {
            return;
        }

        while let Some(_) = self.pop() {}

        unsafe {
            if self.cap == 1 {
                self.alloc.dealloc_one(self.ptr.as_non_null());
            } else {
                let e = self.alloc.dealloc_array(self.ptr.as_non_null(), self.cap);
                if let Err(e) = e {
                    self.alloc.oom(e);
                }
            }
        }
    }
}

&lt;p&gt;なお、&lt;code&gt;T: !Drop&lt;/code&gt; の場合は &lt;code&gt;pop()&lt;/code&gt; を呼ぶ処理を省略できる。
&lt;code&gt;T: Drop&lt;/code&gt; かどうかは &lt;a href=&#34;https://doc.rust-lang.org/nightly/std/mem/fn.needs_drop.html&#34;&gt;&lt;code&gt;mem::needs_drop()&lt;/code&gt;&lt;/a&gt; で判定できる。&lt;/p&gt;
if mem::needs_drop::&lt;T&gt;() {
    while let Some(_) = self.pop() {}
}

&lt;p&gt;しかし、この最適化を施しても効果はほぼ見られなかった。
LLVMの最適化がかなり強いらしい。&lt;/p&gt;

&lt;p&gt;ちなみに、
&lt;a href=&#34;https://doc.rust-lang.org/nightly/src/alloc/vec.rs.html#2108-2116&#34;&gt;標準ライブラリの &lt;code&gt;Drop for Vec&lt;/code&gt; の実装&lt;/a&gt; では、
&lt;code&gt;ptr::drop_in_place()&lt;/code&gt; を使って &lt;code&gt;Drop for [T]&lt;/code&gt; にフォールバックしているようだ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Vecの実装 in Rust - Push &amp; Pop</title>
      <link>/post/implementingvecinrust/push_and_pop/</link>
      <pubDate>Wed, 21 Feb 2018 00:00:00 +0900</pubDate>
      
      <guid>/post/implementingvecinrust/push_and_pop/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;No page found with path or logical name &#34;post/ImplementingVecInRust/allocating_memory&#34;.
&#34;&gt;前回&lt;/a&gt; に引き続き、
&lt;a href=&#34;https://doc.rust-lang.org/nomicon&#34;&gt;The Rustnomicon&lt;/a&gt; の &lt;a href=&#34;https://doc.rust-lang.org/nomicon/vec.html&#34;&gt;Implementing &lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; をやってみる。&lt;/p&gt;

&lt;p&gt;コード全体は &lt;a href=&#34;https://github.com/ordovicia/rustnomicon_vec.git&#34;&gt;GitHub上のリポジトリ&lt;/a&gt; にある。&lt;/p&gt;

&lt;p&gt;rustcのバージョンは以下のとおり。&lt;/p&gt;
$ rustc --version
rustc 1.25.0-nightly (27a046e93 2018-02-18)

&lt;h2 id=&#34;push-and-pop-https-doc-rust-lang-org-nomicon-vec-push-pop-html:c8c6a45ab74a63250532d84be36c96ef&#34;&gt;&lt;a href=&#34;https://doc.rust-lang.org/nomicon/vec-push-pop.html&#34;&gt;Push and Pop&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;メモリ確保ができるようになったので、push, popを実装する。&lt;/p&gt;

&lt;p&gt;便利メソッドとして &lt;code&gt;OwnedPtr&lt;/code&gt; から &lt;code&gt;*mut T&lt;/code&gt; を取り出す関数を作っておく。&lt;/p&gt;
impl&lt;T: ?Sized&gt; OwnedPtr&lt;T&gt; {
    pub(crate) fn as_ptr(&amp;self) -&gt; *mut T {
        self.ptr.as_ptr()
    }
}

&lt;p&gt;まずは &lt;code&gt;Vec::push()&lt;/code&gt; だが、素直に実装すればよい。
確保したメモリ領域が足りなくなったら伸ばし、&lt;code&gt;ptr::write()&lt;/code&gt; で要素を書き込む。
書き込むアドレスは、&lt;code&gt;OwnedPtr&lt;/code&gt; から取り出した &lt;code&gt;*mut T&lt;/code&gt; に &lt;code&gt;self.len&lt;/code&gt; だけオフセットを加えたものとする。
&lt;code&gt;ptr::write()&lt;/code&gt; 時にpanicした場合を考慮して、&lt;code&gt;self.len&lt;/code&gt; のインクリメントは最後におこなう。&lt;/p&gt;
impl&lt;T&gt; Vec&lt;T&gt; {
    pub fn push(&amp;mut self, elem: T) {
        if self.len == self.cap {
            self.grow();
        }

        unsafe {
            let ptr_last = self.ptr.as_ptr().offset(self.len as isize);
            ptr::write(ptr_last, elem);
        }

        self.len += 1;
    }
}

&lt;p&gt;&lt;code&gt;Vec::pop()&lt;/code&gt; も同様に、&lt;code&gt;ptr::read()&lt;/code&gt; を使い実装する。
読み込むアドレスは、&lt;code&gt;OwnedPtr&lt;/code&gt; から取り出した &lt;code&gt;*mut T&lt;/code&gt; に &lt;code&gt;self.len&lt;/code&gt; だけオフセットを加えたものとする。&lt;/p&gt;
impl&lt;T&gt; Vec&lt;T&gt; {
    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.len == 0 {
            None
        } else {
            self.len -= 1;

            unsafe {
                let ptr_last = self.ptr.as_ptr().offset(self.len as isize);
                Some(ptr::read(ptr_last))
            }
        }
    }
}

&lt;p&gt;簡単なテストを書き、動作確認しておく。&lt;/p&gt;
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn push_pop() {
        let mut v = Vec::new();

        const ELEM_NUM: usize = 32;
        let elems = 0..ELEM_NUM;

        for (i, e) in elems.clone().enumerate() {
            v.push(e);
            assert_eq!(v.len(), i + 1);
        }

        for (i, e) in elems.rev().enumerate() {
            let p = v.pop();
            assert!(p.is_some() &amp;&amp; p.unwrap() == e);
            assert_eq!(v.len(), ELEM_NUM - 1 - i);
        }
    }
}
</description>
    </item>
    
    <item>
      <title>Vecの実装 in Rust - メモリ確保</title>
      <link>/post/implementingvecinrust/allocating_memory/</link>
      <pubDate>Tue, 20 Feb 2018 00:00:01 +0900</pubDate>
      
      <guid>/post/implementingvecinrust/allocating_memory/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;No page found with path or logical name &#34;post/ImplementingVecInRust/layout&#34;.
&#34;&gt;前回&lt;/a&gt; に引き続き、
&lt;a href=&#34;https://doc.rust-lang.org/nomicon&#34;&gt;The Rustnomicon&lt;/a&gt; の &lt;a href=&#34;https://doc.rust-lang.org/nomicon/vec.html&#34;&gt;Implementing &lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; をやってみる。&lt;/p&gt;

&lt;p&gt;コード全体は &lt;a href=&#34;https://github.com/ordovicia/rustnomicon_vec.git&#34;&gt;GitHub上のリポジトリ&lt;/a&gt; にある。&lt;/p&gt;

&lt;p&gt;rustcのバージョンは以下のとおり。&lt;/p&gt;
$ rustc --version
rustc 1.25.0-nightly (27a046e93 2018-02-18)

&lt;h2 id=&#34;allocating-memory-https-doc-rust-lang-org-nomicon-vec-alloc-html:abeecce82fc499abb72f8c982f00e742&#34;&gt;&lt;a href=&#34;https://doc.rust-lang.org/nomicon/vec-alloc.html&#34;&gt;Allocating Memory&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;この節に書かれているアロケータ周りのAPIは古い。
現在のRustでは、メモリアロケータ周りのAPIについて &lt;a href=&#34;https://github.com/rust-lang/rfcs/pull/1398&#34;&gt;RFC&lt;/a&gt; がマージされ、
&lt;a href=&#34;https://github.com/rust-lang/rust/issues/32838&#34;&gt;詳細な設計と実装が進んでいる&lt;/a&gt;｡
今回の実装では、このAPIを使っていく。&lt;/p&gt;

&lt;p&gt;まず、上で定義した &lt;code&gt;Vec&lt;/code&gt; 構造体を修正する必要がある。
新しいメモリアロケータAPIでは、アロケータが構造体として提供されるようになった（もともとは &lt;code&gt;heap::allocate()&lt;/code&gt; のような関数だった）。
今回はデフォルトのアロケータ &lt;a href=&#34;https://doc.rust-lang.org/nightly/std/heap/struct.Heap.html&#34;&gt;&lt;code&gt;heap::Heap&lt;/code&gt;&lt;/a&gt; を用いる。&lt;/p&gt;
use std::heap::Heap;

pub struct Vec&lt;T&gt; {
    ptr: OwnedPtr&lt;T&gt;,
    cap: usize,
    len: usize,
    alloc: Heap,
}

&lt;p&gt;メモリ領域を割り当てていく。
本来、&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; が &lt;a href=&#34;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&#34;&gt;ZST (Zero Sized Type)&lt;/a&gt; のときにも対応しないといけないが、
特殊な対応が必要になるので、とりあえず今のところはZSTでないことを前提とする。&lt;/p&gt;
use std::mem;

impl&lt;T&gt; Vec&lt;T&gt; {
    pub fn new() -&gt; Self {
        assert!(mem::size_of::&lt;T&gt;() != 0, &#34;We&#39;re not ready to handle ZSTs&#34;);

        Vec {
            ptr: OwnedPtr::empty(),
            cap: 0,
            len: 0,
            alloc: Heap,
        }
    }
}

&lt;p&gt;&lt;code&gt;Vec::push()&lt;/code&gt; などで実際にメモリ領域をアロケーションし伸ばしていくときの動作を実装する。
先に実装を見せる。&lt;/p&gt;
impl&lt;T: ?Sized&gt; OwnedPtr&lt;T&gt; {
    pub(crate) fn with_non_null(ptr: NonNull&lt;T&gt;) -&gt; Self {
        OwnedPtr {
            ptr,
            _marker: PhantomData,
        }
    }

    pub(crate) fn as_non_null(&amp;self) -&gt; NonNull&lt;T&gt; {
        self.ptr
    }
}
use std::heap::{Alloc, Heap};

impl&lt;T&gt; Vec&lt;T&gt; {
    fn grow(&amp;mut self) {
        let (new_cap, ptr) = if self.cap == 0 {
            (1, self.alloc.alloc_one::&lt;T&gt;())
        } else {
            let old_num_bytes = self.cap * mem::size_of::&lt;T&gt;();
            assert!(                                                // (*) explained below
                old_num_bytes &lt;= (::std::isize::MAX as usize) / 2,
                &#34;capacity overflow&#34;
            );

            unsafe {
                let new_cap = self.cap * 2;
                let ptr = self.alloc
                    .realloc_array::&lt;T&gt;(self.ptr.as_non_null(), self.cap, new_cap);
                (new_cap, ptr)
            }
        };

        if let Err(e) = ptr {
            self.alloc.oom(e);
        }

        self.ptr = OwnedPtr::with_non_null(ptr.unwrap());
        self.cap = new_cap;
    }
}

&lt;p&gt;最初の要素をpushするとき（&lt;code&gt;self.cap == 0&lt;/code&gt; のとき）は、
&lt;a href=&#34;https://doc.rust-lang.org/nightly/std/heap/trait.Alloc.html#method.alloc_one&#34;&gt;&lt;code&gt;Alloc::alloc_one&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt; を利用する。
&lt;code&gt;T&lt;/code&gt; 型の値を一つおける領域を確保してくれる。&lt;/p&gt;

&lt;p&gt;またpushするときは、&lt;a href=&#34;https://doc.rust-lang.org/nightly/std/heap/trait.Alloc.html#method.realloc_array&#34;&gt;&lt;code&gt;Alloc::realloc_array&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt; を呼ぶ。
要素を指定の個数おける領域を再確保する。&lt;/p&gt;

&lt;h3 id=&#34;メモリ確保失敗:abeecce82fc499abb72f8c982f00e742&#34;&gt;メモリ確保失敗&lt;/h3&gt;

&lt;p&gt;Rustでのメモリアロケーションでは、いくつか考慮すべき事項がある。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Alloc::alloc_one&amp;lt;T&amp;gt;()&lt;/code&gt; などの戻り値の型は &lt;code&gt;Result&amp;lt;NonNull&amp;lt;T&amp;gt;, AllocErr&amp;gt;&lt;/code&gt; である。
OOM (Out of Memory)状態に陥るなどしてメモリ確保に失敗すると
&lt;a href=&#34;https://doc.rust-lang.org/nightly/std/heap/enum.AllocErr.html&#34;&gt;&lt;code&gt;AllocErr&lt;/code&gt;&lt;/a&gt; が返る。&lt;/p&gt;

&lt;p&gt;Rustの標準ライブラリでは、メモリ確保に失敗した場合 &lt;code&gt;abort&lt;/code&gt; する。
&lt;code&gt;panic!()&lt;/code&gt; でないのは、&lt;code&gt;panic!()&lt;/code&gt; に伴うスタックの巻き戻し操作自体にメモリアロケーションが必要になるからである。&lt;/p&gt;

&lt;p&gt;この &lt;code&gt;abort&lt;/code&gt; 処理は &lt;a href=&#34;https://doc.rust-lang.org/nightly/std/heap/trait.Alloc.html#method.oom&#34;&gt;&lt;code&gt;Alloc::oom()&lt;/code&gt;&lt;/a&gt; で実行できる。&lt;/p&gt;

&lt;h3 id=&#34;llvmのメモリアロケーション:abeecce82fc499abb72f8c982f00e742&#34;&gt;LLVMのメモリアロケーション&lt;/h3&gt;

&lt;p&gt;RustコンパイラがバックエンドとしているLLVMにおけるアドレス管理には少々クセがあり、配列のインデックスが符号付きで表されるらしい。
従って、確保できる要素数は最大で &lt;code&gt;isize::MAX (= usize::MAX / 2)&lt;/code&gt; となる。
実際には、2 byte以上の型は先にアドレスが &lt;code&gt;usize::MAX&lt;/code&gt; を超えるため、要素数による制限は1 byteの型についてのみ考慮すればよいが、
配列のreinterpret操作などに起因するコーナーケースを潰すため、標準ライブラリではすべての型について要素数を &lt;code&gt;isize::MAX&lt;/code&gt; に制限している &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:abeecce82fc499abb72f8c982f00e742:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:abeecce82fc499abb72f8c982f00e742:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;上で定義した &lt;code&gt;Vec::grow()&lt;/code&gt; におけるアサーション &lt;code&gt;(*)&lt;/code&gt; は、この制限をチェックしている。
&lt;code&gt;old_num_bytes &amp;lt;= isize::MAX / 2&lt;/code&gt; のとき &lt;code&gt;new_cap &amp;lt;= isize::MAX &amp;amp;&amp;amp; new_num_bytes &amp;lt;= usize::MAX&lt;/code&gt; が満たされる。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:abeecce82fc499abb72f8c982f00e742:1&#34;&gt;ここでは64 bit環境を考える。現在の64 bitマシンはアドレス空間が実際には64 bitではなく44 bitや48 bitなので、アドレスのオーバーフローより先にOOMが起こる。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:abeecce82fc499abb72f8c982f00e742:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Vecの実装 in Rust - 構造体レイアウト</title>
      <link>/post/implementingvecinrust/layout/</link>
      <pubDate>Tue, 20 Feb 2018 00:00:00 +0900</pubDate>
      
      <guid>/post/implementingvecinrust/layout/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/nomicon&#34;&gt;The Rustnomicon&lt;/a&gt; の &lt;a href=&#34;https://doc.rust-lang.org/nomicon/vec.html&#34;&gt;Implementing &lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; をやってみる。&lt;/p&gt;

&lt;p&gt;コード全体は &lt;a href=&#34;https://github.com/ordovicia/rustnomicon_vec.git&#34;&gt;GitHub上のリポジトリ&lt;/a&gt; にある。&lt;/p&gt;

&lt;p&gt;rustcのバージョンは以下のとおり。
このバージョンに基づいて書いていく。&lt;/p&gt;
$ rustc --version
rustc 1.25.0-nightly (27a046e93 2018-02-18)

&lt;h2 id=&#34;subtyping-and-variance-https-doc-rust-lang-org-nomicon-subtyping-html:66b86657894595ae36af47f31c365fda&#34;&gt;&lt;a href=&#34;https://doc.rust-lang.org/nomicon/subtyping.html&#34;&gt;Subtyping and Variance&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;部分型-subtyping:66b86657894595ae36af47f31c365fda&#34;&gt;部分型 (subtyping)&lt;/h3&gt;

&lt;p&gt;&amp;ldquo;Implementing &lt;code&gt;Vec&lt;/code&gt;&amp;rdquo; の最初の節は &lt;a href=&#34;https://doc.rust-lang.org/nomicon/vec-layout.html&#34;&gt;Layout&lt;/a&gt; だが、
事前知識のため変性 (variance)の節から見ていく。&lt;/p&gt;

&lt;p&gt;Rustには &lt;a href=&#34;https://en.wikipedia.org/wiki/Structural_type_system&#34;&gt;構造的部分型 (structural subtyping)&lt;/a&gt; は存在しないが、lifetimeについて部分型が採用されている。
Lifetime &lt;code&gt;&#39;a&lt;/code&gt; が &lt;code&gt;&#39;b&lt;/code&gt; を「含む」あるいは「より長い」ことを意味する &lt;code&gt;&#39;a: &#39;b&lt;/code&gt; が成り立っていれば、 &lt;code&gt;&#39;a&lt;/code&gt; は &lt;code&gt;&#39;b&lt;/code&gt; の部分型である。
「&lt;code&gt;&#39;a&lt;/code&gt; が &lt;code&gt;&#39;b&lt;/code&gt; を含む」のに「部分型である」というのは直感に反するようだが、&lt;code&gt;&#39;a&lt;/code&gt; は &lt;code&gt;&#39;b&lt;/code&gt; に暗黙的に変換できる（置換できる）ので部分型だといえる。&lt;/p&gt;

&lt;h3 id=&#34;変性-variance:66b86657894595ae36af47f31c365fda&#34;&gt;変性 (variance)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science&#34;&gt;変性 (variance)&lt;/a&gt;) は、
型コンストラクタがもつ性質で、引数にとる型やlifetimeの派生関係が、出力される型にどのように伝搬するかを表したもの。
例えば、 &lt;code&gt;&#39;a: &#39;b&lt;/code&gt; ならば &lt;code&gt;&amp;amp;&#39;a T&lt;/code&gt; は &lt;code&gt;&amp;amp;&#39;b T&lt;/code&gt; に暗黙的に変換できる。
このように半順序が保存されて伝搬するとき、&lt;strong&gt;共変 (variant)&lt;/strong&gt; と言う。
これ以外の場合、&lt;strong&gt;非変 (invariant)&lt;/strong&gt; と言う &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:66b86657894595ae36af47f31c365fda:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:66b86657894595ae36af47f31c365fda:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;amp;&#39;a T&lt;/code&gt; は &lt;code&gt;&#39;a&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; どちらについても共変である。
&lt;code&gt;&#39;a&lt;/code&gt; について共変であることで、&lt;code&gt;&#39;a: &#39;b&lt;/code&gt; のとき（&lt;code&gt;&#39;a&lt;/code&gt; が &lt;code&gt;&#39;b&lt;/code&gt; より長いとき） &lt;code&gt;&amp;amp;&#39;a T&lt;/code&gt; が &lt;code&gt;&amp;amp;&#39;b T&lt;/code&gt; に暗黙的に置き換えられる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;amp;&#39;a mut T&lt;/code&gt; は &lt;code&gt;&#39;a&lt;/code&gt; については共変だが、&lt;code&gt;T&lt;/code&gt; について非変である。
これにより、ある種のdangling pointerが回避されている。
例として、次のコードを考える。&lt;/p&gt;
fn overwrite&lt;T: Copy&gt;(input: &amp;mut T, new: &amp;mut T) {
    *input = *new;
}

fn main() {
    let mut forever_str: &amp;&#39;static str = &#34;hello&#34;;
    {
        let string = String::from(&#34;world&#34;);
        overwrite(&amp;mut forever_str, &amp;mut &amp;*string);
    }
    // Oops, printing free&#39;d memory
    println!(&#34;{}&#34;, forever_str);
}

&lt;p&gt;&lt;code&gt;string&lt;/code&gt; のlifetimeを &lt;code&gt;&#39;s&lt;/code&gt; と名付けることにする。
&lt;code&gt;&amp;amp;&#39;a T&lt;/code&gt; は &lt;code&gt;&#39;a&lt;/code&gt; について共変なので、&lt;code&gt;&amp;amp;&#39;static str&lt;/code&gt; は &lt;code&gt;&amp;amp;&#39;s str&lt;/code&gt; に置き換えられる。
従って、もし &lt;code&gt;&amp;amp;mut T&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; について共変だったとすると、 &lt;code&gt;&amp;amp;mut &amp;amp;&#39;static str&lt;/code&gt; は &lt;code&gt;&amp;amp;mut &amp;amp;&#39;s str&lt;/code&gt; の部分型となる。
すると、&lt;code&gt;&amp;amp;mut forever_str&lt;/code&gt; は &lt;code&gt;&amp;amp;mut &amp;amp;*string&lt;/code&gt; と同じ型 &lt;code&gt;&amp;amp;mut &amp;amp;*string&lt;/code&gt; に暗黙的に変換でき、コード中の &lt;code&gt;overwrite()&lt;/code&gt; の呼び出しが有効になる。
そして、ブロックを抜けて &lt;code&gt;string&lt;/code&gt; が破棄されたとき、 &lt;code&gt;forever_str&lt;/code&gt; はdangling pointerとなる。
つまり、 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; を &lt;code&gt;T&lt;/code&gt; について非変にすることで、 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; のスコープが狭くなりdangling pointerが発生することを防いでいる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;amp;&#39;a mut T&lt;/code&gt; と同様に、内部可変性 (interior mutability) をもつ型 &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; も &lt;code&gt;T&lt;/code&gt; について非変となっている。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Fn(T) -&amp;gt; U&lt;/code&gt; は、 &lt;code&gt;T&lt;/code&gt; については非変、&lt;code&gt;U&lt;/code&gt; については共変となっている。
&lt;code&gt;T&lt;/code&gt; について非変であることにより、例えば &lt;code&gt;fn f(&amp;amp;&#39;a str s)&lt;/code&gt; が &lt;code&gt;fn f(&amp;amp;&#39;static str s)&lt;/code&gt; の部分型となる。
もし共変だったとすると、逆に &lt;code&gt;fn f(&amp;amp;&#39;static str s)&lt;/code&gt; が &lt;code&gt;fn f(&amp;amp;&#39;a str s)&lt;/code&gt; で置換できることになり、より強いlifetime制約を要求してしまう。
一方、&lt;code&gt;U&lt;/code&gt; について共変であることにより、例えば &lt;code&gt;fn f(&amp;amp;&#39;a str) -&amp;gt; &amp;amp;&#39;static str&lt;/code&gt; は &lt;code&gt;fn f(&amp;amp;&#39;a str) -&amp;gt; &amp;amp;&#39;a str&lt;/code&gt; に変換できる。&lt;/p&gt;

&lt;h2 id=&#34;phantomdata-https-doc-rust-lang-org-nomicon-phantom-data-html:66b86657894595ae36af47f31c365fda&#34;&gt;&lt;a href=&#34;https://doc.rust-lang.org/nomicon/phantom-data.html&#34;&gt;&lt;code&gt;PhantomData&lt;/code&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;さらに事前知識をおさらいする。&lt;/p&gt;

&lt;p&gt;Rustでは、ジェネリックな構造体などの定義における型引数・lifetime引数がフィールドで使われていないとコンパイルエラーになる。
何らかの理由で未使用の引数を定義に含める必要がある場合、&lt;code&gt;PhantomData&lt;/code&gt; が使われる。&lt;/p&gt;

&lt;p&gt;例えば、スライス &lt;code&gt;&amp;amp;&#39;a [T]&lt;/code&gt; の &lt;code&gt;Iter&lt;/code&gt; は次のように定義されている。&lt;/p&gt;
use std::marker;

struct Iter&lt;&#39;a, T: &#39;a&gt; {
    ptr: *const T,
    end: *const T,
    _marker: marker::PhantomData&lt;&amp;&#39;a T&gt;
}

&lt;p&gt;（&lt;a href=&#34;https://doc.rust-lang.org/nightly/src/core/slice/mod.rs.html#1390-1394&#34;&gt;現在の実装&lt;/a&gt; も同様）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PhantomData&lt;/code&gt; の型引数におくものを注意深く設定することで、&lt;code&gt;PhantomData&lt;/code&gt; がもつ性質をうまくコントロールできる。
&lt;a href=&#34;https://doc.rust-lang.org/nomicon/phantom-data.html#table-of-phantomdata-patterns&#34;&gt;PhantomDataの使いかたの表&lt;/a&gt; にまとまっているが、
重要なものを抜粋する。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; について共変&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; 型の値を所有する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PhantomData&amp;lt;fn() -&amp;gt; T&amp;gt;&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; について共変&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; 型の値を所有しない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;layout-https-doc-rust-lang-org-nomicon-vec-layout-html:66b86657894595ae36af47f31c365fda&#34;&gt;&lt;a href=&#34;https://doc.rust-lang.org/nomicon/vec-layout.html&#34;&gt;Layout&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;やっと &amp;ldquo;Implementing &lt;code&gt;Vec&lt;/code&gt;&amp;rdquo; の最初の節。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; は「連続領域に確保された、動的に要素数の変わる配列」なので、ナイーブには次のように実装しようと考える。&lt;/p&gt;
pub struct Vec&lt;T&gt; {
    ptr: *mut T,    // pointer to contiguous region elements are stored on
    cap: usize,     // capacity of the region
    len: usize,     // number of elements actually stored
}

&lt;p&gt;しかし、この実装には以下の問題がある。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; について共変であるべきだが、&lt;code&gt;*mut T&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; について非変なので、&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; も非変になってしまう

&lt;ul&gt;
&lt;li&gt;フィールドが一つでも非変だと構造体全体が非変になる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; 型の値を所有していない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;さらに、以下の二点が満たされているとよい。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T: Send&lt;/code&gt; なら &lt;code&gt;Vec&amp;lt;T&amp;gt;: Send&lt;/code&gt; としたい

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Sync&lt;/code&gt; についても同様&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ptr&lt;/code&gt; はnullにならないことを型レベルで保証したい

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://doc.rust-lang.org/nomicon/repr-rust.html&#34;&gt;null-pointer-optimization&lt;/a&gt; のため、&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;そこで、&lt;code&gt;ptr&lt;/code&gt; として &lt;code&gt;ptr::NonNull&lt;/code&gt; と &lt;code&gt;PhantomData&lt;/code&gt; を組み合わせて用いることにする。
&lt;a href=&#34;https://doc.rust-lang.org/nightly/std/ptr/struct.NonNull.html&#34;&gt;&lt;code&gt;NonNull&lt;/code&gt;&lt;/a&gt; は1.25.0から安定化される生ポインタのラッパ構造体で、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; について共変&lt;/li&gt;
&lt;li&gt;Nullになってはいけない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という特性をもつ。
&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; が要素を所有することを表しdrop checkerを正しく動作させるため、 &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; を用いる。&lt;/p&gt;
use std::marker::PhantomData;
use std::ptr::NonNull;

pub(crate) struct OwnedPtr&lt;T: ?Sized&gt; {
    ptr: NonNull&lt;T&gt;,
    _marker: PhantomData&lt;T&gt;,
}

unsafe impl&lt;T: ?Sized + Send&gt; Send for OwnedPtr&lt;T&gt; {}
unsafe impl&lt;T: ?Sized + Sync&gt; Sync for OwnedPtr&lt;T&gt; {}

pub struct Vec&lt;T&gt; {
    ptr: OwnedPtr&lt;T&gt;,
    cap: usize,
    len: usize,
}

&lt;p&gt;&lt;code&gt;Vec::new()&lt;/code&gt; の際、空の &lt;code&gt;Vec&lt;/code&gt; にメモリを割り当てないようにすると、&lt;code&gt;Vec::ptr&lt;/code&gt; や &lt;code&gt;OwnedPtr::ptr&lt;/code&gt; はnullになってしまう。
実のところ、&lt;code&gt;NonNull&lt;/code&gt; がnullになってはいけないという制約は、nullをdereferenceしてはいけないという意味で、deref.しないならnullになること自体は問題ない。
&lt;code&gt;Vec&lt;/code&gt; の場合、&lt;code&gt;cap&lt;/code&gt;, &lt;code&gt;len&lt;/code&gt; のチェックが必要になるので、null pointer deref.の発生は防ぎやすい。
Nullとなっている（がアライメントは整っている） &lt;code&gt;NonNull&lt;/code&gt; は、
&lt;a href=&#34;https://doc.rust-lang.org/nightly/std/ptr/struct.NonNull.html#method.dangling&#34;&gt;&lt;code&gt;NonNull::dangling()&lt;/code&gt;&lt;/a&gt; で作れる。&lt;/p&gt;
impl&lt;T&gt; OwnedPtr&lt;T&gt; {
    pub(crate) fn empty() -&gt; Self {
        OwnedPtr {
            ptr: NonNull::dangling(),
            _marker: PhantomData,
        }
    }
}

&lt;p&gt;なお、&lt;code&gt;NonNull&lt;/code&gt; が持つ特性と &lt;code&gt;Send&lt;/code&gt;, &lt;code&gt;Sync&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; の所有をすべて備える構造体として、
&lt;a href=&#34;https://doc.rust-lang.org/nightly/std/ptr/struct.Unique.html&#34;&gt;&lt;code&gt;ptr::Unique&lt;/code&gt;&lt;/a&gt; があり、現在は使うことができる。
しかし、&lt;a href=&#34;https://github.com/rust-lang/rust/pull/46952&#34;&gt;&lt;code&gt;Unique&lt;/code&gt; は &lt;code&gt;NonNull&lt;/code&gt; に置き換えられ、今後安定化することはない&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:66b86657894595ae36af47f31c365fda:1&#34;&gt;この説明はかなり簡略化されたもの。ここでのvariantは実際にはcovariantと呼ばれる。また、半順序が逆向きに伝搬するとき、&lt;strong&gt;反変 (contravariant)&lt;/strong&gt; と言う。&lt;code&gt;fn(T)&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; について反変である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:66b86657894595ae36af47f31c365fda:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>シェルの実装 in Rust</title>
      <link>/post/shell_in_rust/</link>
      <pubDate>Thu, 12 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/shell_in_rust/</guid>
      <description>

&lt;h2 id=&#34;概要:158b60adfcba82f928c98a0450cbf948&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;Rustで簡単なシェルを書きました。
コードは &lt;a href=&#34;https://github.com/ordovicia/rush.git&#34;&gt;github&lt;/a&gt; にあります。&lt;/p&gt;

&lt;p&gt;インタラクティブでのみ動作し、リダイレクトとパイプが使えます。
ビルトインコマンドは &lt;code&gt;cd&lt;/code&gt; のみ実装されています。&lt;/p&gt;

&lt;h2 id=&#34;入力:158b60adfcba82f928c98a0450cbf948&#34;&gt;入力&lt;/h2&gt;

&lt;p&gt;Readline alternativeの &lt;a href=&#34;https://github.com/antirez/linenoise&#34;&gt;linenoise&lt;/a&gt; を使ったことがあったので、それに似ている &lt;a href=&#34;https://crates.io/crates/rustyline&#34;&gt;rustyline&lt;/a&gt; を使いました。
一行読んでパーサに渡しているだけです。&lt;/p&gt;

&lt;h2 id=&#34;パース:158b60adfcba82f928c98a0450cbf948&#34;&gt;パース&lt;/h2&gt;

&lt;p&gt;パーサコンビネータの &lt;a href=&#34;https://crates.io/crates/nom&#34;&gt;nom&lt;/a&gt; を使いました。
だいたい以下のような文法です。&lt;/p&gt;
arg_list     := token+

redir_in     := &#34;&lt;&#34; token
redir_trunc  := &#34;&gt;&#34; token
redir_append := &#34;&gt;&gt;&#34; token
redir_out    := redir_trunc
              | redir_append

proc_cdr     := arg_list proc_out?
pipe_proc    := &#34;|&#34; proc_cdr
proc_out     := pipe_proc
              | redir_out

proc_car     := arg_list
              | arg_list proc_out
              | arg_list redir_in proc_out?

end_job      := eof | &#34;;&#34; | &#34;\n&#34; | &#34;\r&#34;
job          := proc_car &#34;&amp;&#34;? end_job

&lt;p&gt;nomを使うと簡単にパーサーが書けるのですが、今回は失敗だったと思っています。
というのも、シェルはリダイレクトの位置に自由度があるからです。
例えば &lt;code&gt;cmd &amp;lt; file0 &amp;gt; file1&lt;/code&gt; は &lt;code&gt;&amp;lt; file0 cmd &amp;gt; file1&lt;/code&gt; とも書けます。
nomでこれに対応するのは面倒なので、今回は &lt;code&gt;cmd0 &amp;lt; file0 &amp;gt; file1&lt;/code&gt; の形式（にパイプを加えたもの）のみ認識するようになっています。&lt;/p&gt;

&lt;p&gt;シェルの文法はそんなに難しくないので、パーサーを手書きすれば自由度にうまく対処できたのではないかと思います。&lt;/p&gt;

&lt;h2 id=&#34;ジョブ実行:158b60adfcba82f928c98a0450cbf948&#34;&gt;ジョブ実行&lt;/h2&gt;

&lt;p&gt;ジョブとプロセスの構造は次のようになっています。&lt;/p&gt;

&lt;p&gt;プロセスは &lt;code&gt;Input::Pipe&lt;/code&gt;, &lt;code&gt;Output::Pipe&lt;/code&gt; によって他のプロセスとパイプで繋がり、&lt;code&gt;Input::Redirect&lt;/code&gt;, &lt;code&gt;Input::Redirect&lt;/code&gt; によってファイルリダイレクションを表しています。&lt;/p&gt;
pub(super) struct Job {
    process_list: process::Process,
    mode: JobMode,
}

pub(crate) struct Process {
    argument_list: Vec&lt;String&gt;,
    input: Input,
    output: Output,
}

pub(crate) enum Input {
    Inherit,
    Redirect(String),
    Pipe,
}

pub(crate) enum Output {
    Inherit,
    Redirect(OutputRedirect),
    Pipe(Box&lt;Process&gt;),
}

&lt;p&gt;実行は &lt;code&gt;std::process&lt;/code&gt; を使っています。
&lt;code&gt;Process::spawn()&lt;/code&gt;, &lt;code&gt;spawn_rec()&lt;/code&gt; が &lt;code&gt;Input&lt;/code&gt;, &lt;code&gt;Output&lt;/code&gt; に従って入出力を設定し、&lt;code&gt;spawn_one()&lt;/code&gt; がspawnします。&lt;/p&gt;

&lt;p&gt;パイプやリダイレクトから &lt;code&gt;std::process::Stdin&lt;/code&gt; を作るには、生のファイルディスクリプタを経由する必要があるようです。
この操作はunsafeになっています。&lt;/p&gt;
use std::process as stdproc;

pub(super) fn spawn(&amp;self) -&gt; Result&lt;ChildList&gt; {
    let stdin = match self.input {
        Input::Inherit =&gt; stdproc::Stdio::inherit(),
        Input::Redirect(ref file_name) =&gt; ...,
        Input::Pipe =&gt; unreachable!(),
    };

    self.spawn_rec(stdin)
}

fn spawn_rec(&amp;self, stdin: stdproc::Stdio) -&gt; Result&lt;ChildList&gt; {
    let (head, piped) = match self.output {
        Output::Inherit =&gt; {
            let head = self.spawn_one(stdin, stdproc::Stdio::inherit())?;
            (head, None)
        }
        Output::Redirect(ref redir_out) =&gt; {
            let file = ...;
            let head = self.spawn_one(stdin, file)?;
            (head, None)
        }
        Output::Pipe(ref piped) =&gt; {
            let head = self.spawn_one(stdin, stdproc::Stdio::piped())?;
            let stdin = ...;
            let piped = piped.spawn_rec(stdin)?;
            (head, Some(Box::new(piped)))
        }
    };

    Ok(ChildList { head, piped })
}

fn spawn_one(&amp;self, stdin: stdproc::Stdio, stdout: stdproc::Stdio) -&gt; Result&lt;Child&gt; {
    ...

    stdproc::Command::new(&amp;self.argument_list[0])
        .args(&amp;self.argument_list[1..])
        .stdin(stdin)
        .stdout(stdout)
        .spawn()
        .map(Child::External)
        .map_err(Error::from)
}

&lt;h2 id=&#34;future-work-バックグラウンド実行:158b60adfcba82f928c98a0450cbf948&#34;&gt;Future Work: バックグラウンド実行&lt;/h2&gt;

&lt;p&gt;バックグラウンド実行にも対応しようと思ったのですが、 &lt;code&gt;std::process&lt;/code&gt; だけではできず、libcバインディングが必要になるようでした。&lt;/p&gt;

&lt;p&gt;バックグラウンド実行くらいは対応しないとシェルを書いたとは言えないですね&amp;hellip;&amp;hellip;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>パトリシア木の実装 in Rust</title>
      <link>/post/implementing_patricia_tree_in_rust/</link>
      <pubDate>Mon, 09 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/implementing_patricia_tree_in_rust/</guid>
      <description>

&lt;p&gt;Rustでパトリシア木を書きました。
写経以外でRustを書くのは初めてです。&lt;/p&gt;

&lt;h2 id=&#34;パトリシア木とは:ba2f640788bae4c2481354cc702c489f&#34;&gt;パトリシア木とは&lt;/h2&gt;

&lt;p&gt;パトリシア木(Patricia tree)または基数木(Radix tree)とは、
文字列を格納するためのデータ構造です。
実際には文字列以外にも、辞書式順序が定義できる集合なら適用でき、整数やビット列でも可能です。&lt;/p&gt;

&lt;p&gt;まず、トライ木というデータ構造があり、これは文字列を格納するために、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;各ノードに文字をもたせ、&lt;/li&gt;
&lt;li&gt;あるノードの子は、自身に対応する文字列をprefixにもつ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という構造になっています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://commons.wikimedia.org/wiki/File:Trie_example.svg#/media/File:Trie_example.svg&#34;&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/b/be/Trie_example.svg&#34; alt=&#34;Trie example.svg&#34; height=&#34;145&#34; width=&#34;155&#34;&gt;&lt;/a&gt;&lt;br&gt;By &lt;a href=&#34;https://en.wikipedia.org/wiki/User:Booyabazooka&#34; class=&#34;extiw&#34; title=&#34;en:User:Booyabazooka&#34;&gt;Booyabazooka&lt;/a&gt; (based on PNG image by &lt;a href=&#34;https://en.wikipedia.org/wiki/User:Deco&#34; class=&#34;extiw&#34; title=&#34;en:User:Deco&#34;&gt;Deco&lt;/a&gt;). Modifications by &lt;a href=&#34;//commons.wikimedia.org/wiki/User:Superm401&#34; class=&#34;mw-redirect&#34; title=&#34;User:Superm401&#34;&gt;Superm401&lt;/a&gt;. - own work (based on PNG image by &lt;a href=&#34;https://en.wikipedia.org/wiki/User:Deco&#34; class=&#34;extiw&#34; title=&#34;en:User:Deco&#34;&gt;Deco&lt;/a&gt;), パブリック・ドメイン, &lt;a href=&#34;https://commons.wikimedia.org/w/index.php?curid=1197221&#34;&gt;Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%88%E3%83%A9%E3%82%A4%E6%9C%A8&#34;&gt;トライ木 - Wikipedia&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;トライ木は文字列を一文字ずつに分割するので、無駄なノードが生じます。
例えば&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;test&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;tea&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;teapot&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を格納すると、&lt;/p&gt;
- (root)
  - &#39;t&#39;
    - &#39;e&#39;
      - &#39;s&#39;
        - &#39;t&#39; [leaf]
      - &#39;a&#39;[leaf]
        - &#39;p&#39;
          - &#39;o&#39;
            - &#39;t&#39; [leaf]

&lt;p&gt;という構造になります（格納した値に対応するノードに&lt;code&gt;[leaf]&lt;/code&gt;とつけた）。&lt;/p&gt;

&lt;p&gt;無駄なノードを圧縮するため、
共通部分を文字列にしてひとつのノードに持たせるようにしたのがパトリシア木です。
そのため、パトリシア木の各ノードは文字&lt;strong&gt;列&lt;/strong&gt;をもちます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://commons.wikimedia.org/wiki/File:Patricia_trie.svg#/media/File:Patricia_trie.svg&#34;&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/a/ae/Patricia_trie.svg&#34; alt=&#34;Patricia trie.svg&#34; height=&#34;138&#34; width=&#34;220&#34;&gt;&lt;/a&gt;&lt;br&gt;By Claudio Rocchini - &lt;span class=&#34;int-own-work&#34; lang=&#34;ja&#34;&gt;投稿者自身による作品&lt;/span&gt;, &lt;a href=&#34;http://creativecommons.org/licenses/by/2.5&#34; title=&#34;Creative Commons Attribution 2.5&#34;&gt;CC 表示 2.5&lt;/a&gt;, &lt;a href=&#34;https://commons.wikimedia.org/w/index.php?curid=2118795&#34;&gt;Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上の例は、パトリシア木では&lt;/p&gt;
- (root)
  - &#34;te&#34;
    - &#34;st&#34; [leaf]
    - &#34;a&#34; [leaf]
      - &#34;pot&#34; [leaf]

&lt;p&gt;となります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%9C%A8&#34;&gt;基数木 - Wikipedia&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;パトリシア木の機能と性能:ba2f640788bae4c2481354cc702c489f&#34;&gt;パトリシア木の機能と性能&lt;/h2&gt;

&lt;p&gt;パトリシア木は、検索・挿入・削除などの操作が [tex:O(k)] で可能です
（[tex:k] は最大文字列長）。&lt;/p&gt;

&lt;p&gt;平衡二分木などでは、これらの操作が &lt;a href=&#34;[tex:n] は格納されている要素数&#34;&gt;tex:O(\log n)&lt;/a&gt;で
できますが、それは要素の比較が定数時間でできるという前提のもとで成り立つものです。
文字列を格納する場合、その比較に最悪で [tex:O(k)] かかるので、平衡二分木では遅くなります。
この比較は毎回文字列の先頭からおこなわれるので、
長いprefixを共有している要素が多い場合などに顕著です。&lt;/p&gt;

&lt;p&gt;パトリシア木の場合、文字列の比較は先頭から一度だけおこなえばよいので、
[tex:O(k)] で済むことになります。&lt;/p&gt;

&lt;p&gt;パトリシア木は文字列をキーとする連想配列を表現するのにも使えます。&lt;/p&gt;

&lt;h2 id=&#34;rust実装:ba2f640788bae4c2481354cc702c489f&#34;&gt;Rust実装&lt;/h2&gt;

&lt;p&gt;Rustのバージョンは&lt;code&gt;rustc 1.16.0-nightly (7e38a89a7 2017-01-06)&lt;/code&gt;です。&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/ordovicia/f711d40fcea689e97123f200c0f3b225.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;パトリシア木の実装方法はいくつかあるようですが、
親ノードが子ノードのリストをもつ素朴な方法を取りました。&lt;/p&gt;

&lt;p&gt;検索・挿入・削除はすべて、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ノードがもつ文字列と対象の文字列を上から順に比較していき、&lt;/li&gt;
&lt;li&gt;ノードの文字列が先に終わった（対象の文字列のprefixだった）ときは&lt;/li&gt;
&lt;li&gt;子ノードに残りの文字列をわたして再帰的に実行する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ようになっています。&lt;/p&gt;

&lt;p&gt;子ノードは、最初の文字で比較した順番にソートしてもつようにし、
再帰的に呼び出すノードの決定を二分探索できるようにすることで高速化しました。&lt;/p&gt;

&lt;p&gt;ソースコードをよく見ると、ズルをしている箇所があることがわかります。
あるノードに対応する文字列を削除するとき、そのノードの子が、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0個の場合 &amp;ndash; そのノードを親ノードから消し、親ノードについて圧縮処理をおこなう。&lt;/li&gt;
&lt;li&gt;1個の場合 &amp;ndash; そのノードがもつ文字列を、子ノードのものと連結させる。&lt;/li&gt;
&lt;li&gt;2個以上の場合 &amp;ndash; そのノードが文字列の終端であることを示す&lt;code&gt;is_leaf&lt;/code&gt;フラグを下ろす&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;と処理すればよいのですが、上のソースコードでは、0個の場合の処理を、
&lt;code&gt;is_leaf&lt;/code&gt;フラグを下ろすことで代えています。
これは&lt;code&gt;PatriciaTree&lt;/code&gt;structが親へアクセスする手段を持たないためです。
&lt;code&gt;PatriciaTree&lt;/code&gt;に親へのポインタを持たせようとすると実装が面倒になるようだったからで、
今回この処理は省略しました。&lt;/p&gt;

&lt;h3 id=&#34;実装して思ったこと:ba2f640788bae4c2481354cc702c489f&#34;&gt;実装して思ったこと&lt;/h3&gt;

&lt;h4 id=&#34;rustはテストツールやドキュメント化ツールがオールインワンになっていて楽:ba2f640788bae4c2481354cc702c489f&#34;&gt;Rustはテストツールやドキュメント化ツールがオールインワンになっていて楽&lt;/h4&gt;

&lt;p&gt;Rustは、ちゃんとしたテストツールやドキュメント化ツールが公式から提供されていて、
しかもCargoから簡単に扱えるのでかなり楽でした。&lt;/p&gt;

&lt;p&gt;僕がよく使うC++だと、テストツールにはgoogletestやCMakeのCTestなどがあって、
比較したり使いかたを覚えるのが大変です。
ドキュメント化にはDoxygenがデファクトスタンダードになっていて
使いかたも難しくないのでいいですが。&lt;/p&gt;

&lt;p&gt;Rustはテストが同じファイルに書けます。
上に貼ったソースコードだと、&lt;code&gt;test&lt;/code&gt;moduleがテストになっています。
関数などのコメント内に、使用例を兼ねてテストを書くこともできます。
テストをコードのすぐ近くに書けて、&lt;code&gt;$ cargo test&lt;/code&gt;で簡単に実行できて便利です。&lt;/p&gt;

&lt;p&gt;ドキュメントは、&lt;code&gt;$ cargo doc&lt;/code&gt;で生成されます。
&lt;a href=&#34;https://doc.rust-lang.org/std/index.html&#34;&gt;標準ライブラリのリファレンス&lt;/a&gt;
のような形式のドキュメントができ、標準ライブラリへのリンクも貼ってくれます。&lt;/p&gt;

&lt;h4 id=&#34;型をつけるのは大事:ba2f640788bae4c2481354cc702c489f&#34;&gt;型をつけるのは大事&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;exist()&lt;/code&gt;などで文字列をスキャンしていくループでは、ループごとの結果を&lt;code&gt;IteratingState&lt;/code&gt;型で
表すようにしています。
適当に&lt;code&gt;()&lt;/code&gt;型にしてしまっても実装できるのですが、型を付けることでバグが見つかりやすくなりました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;()&lt;/code&gt;型だといろんな文が書けてしまって、&lt;code&gt;return&lt;/code&gt;忘れとかが見落としがちなので、
型を付けることでちゃんとその型を返すようになっていることを保証するといいと思います。&lt;/p&gt;

&lt;p&gt;Rustは最後に書いた式でブロックが型付けされたり、&lt;code&gt;if&lt;/code&gt;や&lt;code&gt;match&lt;/code&gt;が式として使えるので便利です。&lt;/p&gt;

&lt;h4 id=&#34;ownershipがいい:ba2f640788bae4c2481354cc702c489f&#34;&gt;Ownershipがいい&lt;/h4&gt;

&lt;p&gt;Ownershipのおかげで、データの移動がmoveもしくは明示的なreferenceとなります
（もちろん、&lt;code&gt;Copy&lt;/code&gt;traitをimplしているような軽い型は低コストでディープコピーできます）。
そのため、明示的にコピー(clone)しない限り
ownershipの付け替えやreferenceという軽い操作になるので、
コピーコストやmove後の不正なアクセスの可能性をいちいち考えなくてよくなって楽でした。&lt;/p&gt;

&lt;h4 id=&#34;文字列操作が面倒:ba2f640788bae4c2481354cc702c489f&#34;&gt;文字列操作が面倒&lt;/h4&gt;

&lt;p&gt;Rustの&lt;code&gt;&amp;amp;str&lt;/code&gt;型、&lt;code&gt;String&lt;/code&gt;型はC++の&lt;code&gt;std::string&lt;/code&gt;型と中身が異なります。
後者はC/C++の&lt;code&gt;char&lt;/code&gt;型、つまりASCIIコードであるのに対し、
前者がUTF-8にエンコードされた列となっています。&lt;/p&gt;

&lt;p&gt;そのため、簡単にランダムアクセスすることはできず、先頭から順に読んでいくか、
いちど&lt;code&gt;chars()&lt;/code&gt;で&lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt;型に変換する必要があります。&lt;/p&gt;

&lt;p&gt;もちろんRustでも文字列をバイト列として扱うこともできますし、
C++でもワイド幅文字を扱うための型が用意されています。
Rustのprimitiveな型がUTF-8列を扱うというだけです。&lt;/p&gt;

&lt;p&gt;文字列操作が面倒というのは、ASCII文字を扱うような環境でということで、
逆に言うと、Unicode文字を扱いたい場合は、C++の&lt;code&gt;std::string&lt;/code&gt;よりは簡単だと思います。&lt;/p&gt;

&lt;p&gt;今回は文字列を走査するとき、
&lt;code&gt;chars()&lt;/code&gt;でイテレータをつくる方法と、&lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt;に変換する方法を使い分けました。
&lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt;にする必要があったのは、文字列をある位置で前後に分割する必要があるときと、
mutableな操作が必要なときでした。&lt;/p&gt;

&lt;h4 id=&#34;cyclicなデータ構造が面倒:ba2f640788bae4c2481354cc702c489f&#34;&gt;Cyclicなデータ構造が面倒&lt;/h4&gt;

&lt;p&gt;Rustはownershipの概念があるので、木構造で子が親を参照するようなデータ構造をつくるのが面倒です。
そのため今回は性能を一部制限して（要素の削除で実際にはノードを消さなかったところ）、
cyclicにならないようにしました。&lt;/p&gt;

&lt;p&gt;Cyclicにつくるには、子を&lt;code&gt;Rc&lt;/code&gt;, 親を&lt;code&gt;Weak&lt;/code&gt;で囲ってうまいこと実装すればよいようです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Learning Rust - Lifetime</title>
      <link>/post/learningrust/lifetime/</link>
      <pubDate>Wed, 06 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/learningrust/lifetime/</guid>
      <description>

&lt;h1 id=&#34;syntax-and-semantics:4d7c0e9f2f8c6afedc35b165aee74fb6&#34;&gt;Syntax and Semantics&lt;/h1&gt;

&lt;h2 id=&#34;lifetimes:4d7c0e9f2f8c6afedc35b165aee74fb6&#34;&gt;Lifetimes&lt;/h2&gt;

&lt;p&gt;ずっと後回しにしてきましたが、今回はlifetimeを扱います。
Rustのlifetimeは、リソースの寿命に名前をつけて明確にし、
dangling pointerと、それによるuse after freeを防ぐ仕組みです。&lt;/p&gt;

&lt;p&gt;例えば、関数にある参照&lt;code&gt;a&lt;/code&gt;を渡し、それにリソースを生成し、その参照&lt;code&gt;b&lt;/code&gt;を返す場合、
&lt;code&gt;a&lt;/code&gt;の有効範囲は、&lt;code&gt;b&lt;/code&gt;の有効範囲を包含していなくてはなりません。
さもないと、&lt;code&gt;a&lt;/code&gt;が不正な参照になった後(dangling pointer)にも、
&lt;code&gt;a&lt;/code&gt;と同時に不正になった&lt;code&gt;b&lt;/code&gt;がつかわれてしまう(use after free)からです。&lt;/p&gt;

&lt;p&gt;さて、まずはlifetimeに名前をつけるところから始めます。&lt;/p&gt;

&lt;p&gt;Lifetimeを気にしないといけないのは、まずは関数を使うときです。
これまでlifetimeが表舞台には登場してこなかったように、
多くの場合、lifetimeの記述は省略できます(後述)。
省略しない場合は、genericsの型パラメータと同じ所に記述します。&lt;/p&gt;
// implicit
fn foo(x: &amp;i32) {
}

// explicit
fn bar&lt;&#39;a&gt;(x: &amp;&#39;a i32) {
}

&lt;p&gt;Lifetimeは、&lt;code&gt;&#39;a&lt;/code&gt;のように、単一の&lt;code&gt;&#39;&lt;/code&gt;のあとになんらかの名前をつけてあらわします。
二つ以上指定したり、&lt;code&gt;mut&lt;/code&gt;と同時に使うときなどは次のようになります。&lt;/p&gt;
fn foo&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a i32, y: &amp;&#39;b i32) { ... }
fn bar&lt;&#39;a&gt;(x: &amp;&#39;a mut i32) { ... }

&lt;p&gt;戻り値にもlifetimeが指定できます。&lt;/p&gt;
fn x_or_y&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str { ... }
fn x_or_y&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str) -&gt; &amp;&#39;a str { ... }

&lt;p&gt;ひとつ目は、&lt;code&gt;x, y&lt;/code&gt;が同じlifetimeをもち、さらに戻り値も同じになります。
ふたつ目は、&lt;code&gt;x, y&lt;/code&gt;が別々のlifetimeをもて、戻り値は&lt;code&gt;x&lt;/code&gt;と同じlifetimeをもちます。&lt;/p&gt;

&lt;p&gt;なお、参照ではないものにはlifetimeは必要ありません。&lt;/p&gt;

&lt;h3 id=&#34;in-struct-s:4d7c0e9f2f8c6afedc35b165aee74fb6&#34;&gt;In &lt;code&gt;struct&lt;/code&gt;s&lt;/h3&gt;

&lt;p&gt;Structにもlifetimeを指定できます。
フィールドが参照の場合、そのlifetimeを決定するためです。&lt;/p&gt;
struct Foo&lt;&#39;a&gt; {
    x: &amp;&#39;a i32,
}

fn main() {
    let y = &amp;5; // this is the same as `let _y = 5; let y = &amp;_y;`
    let f = Foo { x: y };

    println!(&#34;{}&#34;, f.x);
}

&lt;p&gt;この場合、&lt;code&gt;f.x&lt;/code&gt;は&lt;code&gt;y&lt;/code&gt;と同じlifetimeを持ちます。&lt;/p&gt;

&lt;p&gt;メソッドをimplする際のsyntaxは、genericsのときと同じです。
&lt;code&gt;impl&lt;/code&gt;とstruct名両方に&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;で囲ってlifetimeを記述します。&lt;/p&gt;
impl&lt;&#39;a&gt; Foo&lt;&#39;a&gt; {
    fn x(&amp;self) -&gt; &amp;&#39;a i32 { self.x }
}

&lt;h3 id=&#34;thinking-in-scopes:4d7c0e9f2f8c6afedc35b165aee74fb6&#34;&gt;Thinking in scopes&lt;/h3&gt;

&lt;p&gt;Lifetimeは、言ってしまえば参照変数の有効範囲に名前をつけただけです。
この有効範囲はソースコードの領域として可視化できます。&lt;/p&gt;

&lt;p&gt;まず、関数ローカルに参照を定義します。
この参照のlifetimeは、この関数を抜けるまでです。&lt;/p&gt;
fn main() {
    let y = &amp;5;     // -+ y goes into scope
                    //  |
    // stuff        //  |
                    //  |
}                   // -+ y goes out of scope

&lt;p&gt;参照をフィールドにもつstructを定義し、先ほどの参照でコンストラクトします。
Struct&lt;code&gt;f&lt;/code&gt;のlifetimeは、渡された&lt;code&gt;y&lt;/code&gt;のlifetimeと同じ、つまり関数を抜けるまでです。&lt;/p&gt;
struct Foo&lt;&#39;a&gt; {
    x: &amp;&#39;a i32,
}

fn main() {
    let y = &amp;5;           // -+ y goes into scope
    let f = Foo { x: y }; // -+ f goes into scope
    // stuff              //  |
                          //  |
}                         // -+ f and y go out of scope

&lt;p&gt;この&lt;code&gt;y&lt;/code&gt;と&lt;code&gt;f&lt;/code&gt;を新たにスコープでくくると、&lt;code&gt;y, f&lt;/code&gt;のlifetimeはそのスコープに狭まります。
このスコープ外に参照変数を用意して、&lt;code&gt;f.x&lt;/code&gt;を指すようにすると&amp;hellip;&amp;hellip;&lt;/p&gt;
struct Foo&lt;&#39;a&gt; {
    x: &amp;&#39;a i32,
}

fn main() {
    let x;                    // -+ x goes into scope
                              //  |
    {                         //  |
        let y = &amp;5;           // ---+ y goes into scope
        let f = Foo { x: y }; // ---+ f goes into scope
        x = &amp;f.x;             //  | | error here
    }                         // ---+ f and y go out of scope
                              //  |
    println!(&#34;{}&#34;, x);        //  |
}                             // -+ x goes out of scope

&lt;p&gt;&lt;code&gt;f.x&lt;/code&gt;は狭いスコープでlifetimeが切れますが、それを指す&lt;code&gt;x&lt;/code&gt;のlifetimeは続いています。
ここでdangling pointerが起こっています。
Rustコンパイラはこれを見逃さず、エラーメッセージを吐くことになります。&lt;/p&gt;

&lt;h3 id=&#34;static:4d7c0e9f2f8c6afedc35b165aee74fb6&#34;&gt;&lt;code&gt;&#39;static&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;&#39;static&lt;/code&gt;という特別なlifetimeがあります。
名前からわかるように、このlifetimeは、プログラムの初めから終わりまでです。&lt;/p&gt;

&lt;p&gt;以前にでてきましたが、文字列リテラルは&lt;code&gt;&#39;static&lt;/code&gt;lifetimeを持ちます。
他には、グローバルに定義した&lt;code&gt;static&lt;/code&gt;変数を指す参照は、&lt;code&gt;&#39;static&lt;/code&gt;lifetimeを指定できます。&lt;/p&gt;
let x: &amp;&#39;static str = &#34;Hello, world.&#34;;

static FOO: i32 = 5;
let x: &amp;&#39;static i32 = &amp;FOO;

&lt;h3 id=&#34;lifetime-elision:4d7c0e9f2f8c6afedc35b165aee74fb6&#34;&gt;Lifetime Elision&lt;/h3&gt;

&lt;p&gt;上述したように、関数定義においてlifetimeの記述は多くの場合省略できます。
この、「多くの場合」というのが、次で述べる3つのルールに当てはまる場合です。&lt;/p&gt;

&lt;p&gt;ルールについて説明する前に、関数定義におけるlifetimeには二種類あることを説明します。
&amp;lsquo;Input lifetime&amp;rsquo;と&amp;rsquo;output lifetime&amp;rsquo;です。
その名の通り、input lifetimeは参照型の引数がもつlifetimeで、
output lifetimeは戻り値がもつlifetimeです。&lt;/p&gt;
fn foo&lt;&#39;a&gt;(bar: &amp;&#39;a str) { ... }
fn foo&lt;&#39;a&gt;() -&gt; &amp;&#39;a str { ... }
fn foo&lt;&#39;a&gt;(bar: &amp;&#39;a str) -&gt; &amp;&#39;a str { ... }

&lt;p&gt;ひとつ目の例では、input lifetimeがひとつ、
ふたつ目の例では、output lifetimeがひとつ、
みっつ目の例では、同一のinput lifetimeとoutput lifetimeがひとつずつあります。&lt;/p&gt;

&lt;p&gt;そして、lifetimeが省略できる場合の3つのルールというのが以下になります。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;省略されたlifetimeは、それぞれが別名のlifetimeをあらわす。&lt;/li&gt;
&lt;li&gt;(省略されたかどうかに関わらず)ちょうどひとつのinput lifetimeがあるとき、
省略されたoutput lifetimeは、そのinput lifetimeと同一になる。&lt;/li&gt;
&lt;li&gt;Input lifetimeが複数あり、そのうちひとつが&lt;code&gt;&amp;amp;self&lt;/code&gt;または&lt;code&gt;&amp;amp;mut self&lt;/code&gt;のとき
(つまりstructのメソッドのとき)、
省略されたoutput lifetimeは&lt;code&gt;self&lt;/code&gt;と同じlifetimeになる。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;これらに当てはまらないときは、output lifetimeを省略できません。
明示的に指定する必要があります。&lt;/p&gt;

&lt;h3 id=&#34;examples:4d7c0e9f2f8c6afedc35b165aee74fb6&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;3つのルールに従って、省略されたlifetimeは実際にはどのように推論されるか見てみましょう。&lt;/p&gt;
fn substr(s: &amp;str, until: u32) -&gt; &amp;str; // elided
fn substr&lt;&#39;a&gt;(s: &amp;&#39;a str, until: u32) -&gt; &amp;&#39;a str; // expanded

&lt;p&gt;Input lifetmeがひとつなので、ルール2.によって、
output lifetimeはinput lifetimeとおなじになります。&lt;/p&gt;
fn get_str() -&gt; &amp;str; // ILLEGAL, no inputs

&lt;p&gt;この例はどのルールにも当てはまらないので、output lifetimeを省略できません。
コンパイルエラーになります。&lt;/p&gt;
fn frob(s: &amp;str, t: &amp;str) -&gt; &amp;str; // ILLEGAL, two inputs
fn frob&lt;&#39;a, &#39;b&gt;(s: &amp;&#39;a str, t: &amp;&#39;b str) -&gt; &amp;str; // Expanded: Output lifetime is ambiguous

&lt;p&gt;まず、ルール1.によって&lt;code&gt;s&lt;/code&gt;と&lt;code&gt;t&lt;/code&gt;には別々のlifetimeが推論されます。
しかし、input lifetimeが複数あるにも関わらず、どれも&lt;code&gt;&amp;amp;self, &amp;amp;mut self&lt;/code&gt;ではないので、
output lifetimeを省略できません。&lt;/p&gt;
fn args&lt;T:ToCStr&gt;(&amp;mut self, args: &amp;[T]) -&gt; &amp;mut Command; // elided
fn args&lt;&#39;a, &#39;b, T:ToCStr&gt;(&amp;&#39;a mut self, args: &amp;&#39;b [T]) -&gt; &amp;&#39;a mut Command; // expanded

&lt;p&gt;ルール1.によって、&lt;code&gt;&amp;amp;mut self&lt;/code&gt;と&lt;code&gt;args&lt;/code&gt;は別々のlifetimeを持ちます。
Input lifetimeの一つが&lt;code&gt;&amp;amp;mut self&lt;/code&gt;なので、ルール3.によって、戻り値のlifetimeは、
&lt;code&gt;&amp;amp;mut self&lt;/code&gt;と同じになります。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;おもったほど難しくはありませんでしたね。
Lifetimeについては以上です。
同時に、Rustのsyntax and semaiticsについて学ぶのは今回で最後にしようと思います。
まだ&lt;a href=&#34;https://doc.rust-lang.org/stable/book/syntax-and-semantics.html&#34;&gt;公式リファレンスのsyntax and semantics部&lt;/a&gt;
には、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Crates and Modules&lt;/li&gt;
&lt;li&gt;Macros&lt;/li&gt;
&lt;li&gt;Raw pointers&lt;/li&gt;
&lt;li&gt;&amp;lsquo;unsafe&amp;rsquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;が残っていますが、最初の二つは長いので読むだけにしておきたいし、
残り二つはなるべく使わないようにするほうがいいでしょう。
FFIなどで必要になりそうですが、しばらくは触れないでおきます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Learning Rust - Deref Coercions</title>
      <link>/post/learningrust/deref_coercions/</link>
      <pubDate>Sun, 03 Jan 2016 13:00:00 +0900</pubDate>
      
      <guid>/post/learningrust/deref_coercions/</guid>
      <description>

&lt;h1 id=&#34;syntax-and-semantics:baf7ebc3b85ad1108f122d20444630cc&#34;&gt;Syntax and Semantics&lt;/h1&gt;

&lt;h2 id=&#34;deref-coercions:baf7ebc3b85ad1108f122d20444630cc&#34;&gt;&lt;code&gt;Deref&lt;/code&gt; coercions&lt;/h2&gt;

&lt;p&gt;前回はtraitによる演算子のoverloadを扱いました。
Overloadできる演算子には、間接参照演算子&lt;code&gt;*&lt;/code&gt;を実装する、&lt;code&gt;Deref&lt;/code&gt;traitがあります。
この&lt;code&gt;Deref&lt;/code&gt;traitはユーザー定義ポインタ型の間接参照に使えますが、
すこし特別な機能も持っています。&lt;/p&gt;

&lt;p&gt;まずは普通の使いかたから。
&lt;code&gt;DerefExample&lt;/code&gt;というポインタっぽい型を定義し、&lt;code&gt;Deref&lt;/code&gt;traitをimplします。
間接参照先の型を&lt;code&gt;Target&lt;/code&gt;というassociation typeに指定します。&lt;/p&gt;
use std::ops::Deref;

struct DerefExample&lt;T&gt; {
    value: T,
}

impl&lt;T&gt; Deref for DerefExample&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.value
    }
}

fn main() {
    let x = DerefExample { value: &#39;a&#39; };
    assert_eq!(&#39;a&#39;, *x);
}

&lt;p&gt;それでは&lt;code&gt;Deref&lt;/code&gt;の何が特別かというと、次のようなルールがあります。&lt;/p&gt;

&lt;p&gt;型&lt;code&gt;U&lt;/code&gt;に対して、&lt;code&gt;Deref&amp;lt;Target = T&amp;gt;&lt;/code&gt;をimplすると、&lt;code&gt;&amp;amp;U&lt;/code&gt;型の値は暗黙的に&lt;code&gt;&amp;amp;T&lt;/code&gt;に変換できる。&lt;/p&gt;

&lt;p&gt;例を見てみます。&lt;/p&gt;
fn foo(s: &amp;str) {
    //
}

let owned = &#34;Hello&#34;.to_string(); // owned: String

// String implements Deref&lt;Target = str&gt;
// Thus, &amp;String will coerced to &amp;str
foo(&amp;owned);

&lt;p&gt;&lt;code&gt;String&lt;/code&gt;は&lt;code&gt;Deref&amp;lt;Target = str&amp;gt;&lt;/code&gt;をimplされているので、
&lt;code&gt;&amp;amp;String&lt;/code&gt;は暗黙的に&lt;code&gt;&amp;amp;str&lt;/code&gt;に変換され、&lt;code&gt;foo()&lt;/code&gt;に渡されます。&lt;/p&gt;

&lt;p&gt;他には、リファレンスカウンタをもつ&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;型は、&lt;code&gt;Deref&amp;lt;Target = T&amp;gt;&lt;/code&gt;をimplされています。
よって、&lt;code&gt;&amp;amp;Rc&amp;lt;T&amp;gt;&lt;/code&gt;型の値は暗黙的に&lt;code&gt;&amp;amp;T&lt;/code&gt;型にキャストできます。&lt;/p&gt;
use std::rc::Rc;

fn foo(s: &amp;str) {
    //
}

let owned = &#34;Hello&#34;.to_string(); // owned: String
let counted = Rc::new(owned); // counted: Rc&lt;String&gt;

foo(&amp;counted); // &amp;Rc&lt;String&gt; -&gt; &amp;String -&gt; &amp;str

&lt;p&gt;この例では、&lt;code&gt;&amp;amp;Rc&amp;lt;String&amp;gt;&lt;/code&gt;から&lt;code&gt;&amp;amp;String&lt;/code&gt;を経て&lt;code&gt;&amp;amp;str&lt;/code&gt;へ、二段階のキャストが起こっています。&lt;/p&gt;

&lt;h3 id=&#34;deref-and-method-calls:baf7ebc3b85ad1108f122d20444630cc&#34;&gt;Deref and method calls&lt;/h3&gt;

&lt;p&gt;もう一つ、&lt;code&gt;Deref&lt;/code&gt;には特別な機能があります。
それは、メソッドをよぶときは&lt;code&gt;*&lt;/code&gt;を省略して、間接参照できるということです。&lt;/p&gt;
struct Foo;

impl Foo {
    fn foo(&amp;self) { println!(&#34;Foo&#34;); }
}

let f = &amp;&amp;Foo;

f.foo();

&lt;p&gt;&lt;code&gt;f&lt;/code&gt;は&lt;code&gt;&amp;amp;&amp;amp;Foo&lt;/code&gt;型ですが、&lt;code&gt;&amp;amp;Foo&lt;/code&gt;をとるメソッドが呼べます。
これは、コンパイラが自動的に&lt;code&gt;*&lt;/code&gt;を挿入してくれるからです。
&lt;code&gt;*&lt;/code&gt;は必要なだけ挿入されるので、&lt;code&gt;(&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;f).foo()&lt;/code&gt;みたいなのもコンパイルできます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Learning Rust - Operators and Overloading</title>
      <link>/post/learningrust/operators_and_overloading/</link>
      <pubDate>Sun, 03 Jan 2016 12:00:00 +0900</pubDate>
      
      <guid>/post/learningrust/operators_and_overloading/</guid>
      <description>

&lt;h1 id=&#34;syntax-and-semantics:06ac19f7cde59a5dad601556399c0cba&#34;&gt;Syntax and Semantics&lt;/h1&gt;

&lt;h2 id=&#34;operators-and-overloading:06ac19f7cde59a5dad601556399c0cba&#34;&gt;Operators and Overloading&lt;/h2&gt;

&lt;p&gt;Rustには一般的な関数のoverload機能はありませんが、
いくつかの演算子はoverloadすることができます。
演算子のoverloadは、traitの実装によって実現します。&lt;/p&gt;
use std::ops::Add;

#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point { x: self.x + other.x, y: self.y + other.y }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 0 };
    let p2 = Point { x: 2, y: 3 };

    let p3 = p1 + p2;

    println!(&#34;{:?}&#34;, p3);
}

&lt;p&gt;Overloadできる演算子は&lt;code&gt;std::ops&lt;/code&gt;に定義されています。
たとえば加算&lt;code&gt;+&lt;/code&gt;演算子をoverloadしたいときは、&lt;code&gt;Add&lt;/code&gt;traitの&lt;code&gt;add()&lt;/code&gt;関数を実装します。&lt;/p&gt;

&lt;p&gt;他に、減算&lt;code&gt;-&lt;/code&gt;をoverloadするときは、&lt;code&gt;Sub&lt;/code&gt;traitの&lt;code&gt;sub()&lt;/code&gt;関数を実装します。&lt;/p&gt;
impl Sub for Point {
    type Output = Point;

    fn sub(self, other: Point) -&gt; Point {
        Point {x: self.x - other.x, y: self.y - other.y}
    }
}

let p4 = p1 - p2;

println!(&#34;{:?}&#34;, p4);

&lt;p&gt;&lt;code&gt;Add&lt;/code&gt;traitについて詳しく見てみましょう。
定義は次のようになっています。&lt;/p&gt;
pub trait Add&lt;RHS = Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}

&lt;p&gt;右辺は型パラメータ&lt;code&gt;RHS&lt;/code&gt;になっています。
デフォルト値が自分自身なので、&lt;code&gt;Point&lt;/code&gt;に&lt;code&gt;Point&lt;/code&gt;を足す例だと型パラメータを省略できます。
計算した結果の型は、associated typeである&lt;code&gt;Output&lt;/code&gt;に指定します。&lt;/p&gt;

&lt;p&gt;よって、&lt;code&gt;Point&lt;/code&gt;に&lt;code&gt;i32&lt;/code&gt;を足して&lt;code&gt;f64&lt;/code&gt;を返す関数は、次のようになります。&lt;/p&gt;
impl Add&lt;i32&gt; for Point {
    type Output = f64;

    fn add(self, rhs: i32) -&gt; f64 {
        //
    }
}

&lt;h2 id=&#34;using-operator-traits-in-generic-structs:06ac19f7cde59a5dad601556399c0cba&#34;&gt;Using operator traits in generic structs&lt;/h2&gt;

&lt;p&gt;以前traitを学んだときに、
&lt;code&gt;Square&lt;/code&gt;というstructに&lt;code&gt;HasArea&lt;/code&gt;traitをimplして面積を求める関数を実装しました。
その時は&lt;code&gt;Square&lt;/code&gt;の要素は&lt;code&gt;f64&lt;/code&gt;だったりしたのですが、
もっとジェネリックな&lt;code&gt;Square&lt;/code&gt;にしてみます。&lt;/p&gt;

&lt;p&gt;このとき、&lt;code&gt;Square&lt;/code&gt;の内部型&lt;code&gt;T&lt;/code&gt;に対して掛け算をおこなって面積を計算しますが、
&lt;code&gt;T&lt;/code&gt;に乗算演算子&lt;code&gt;*&lt;/code&gt;が使える必要があります。
そこで&lt;code&gt;T&lt;/code&gt;が&lt;code&gt;Mul&amp;lt;Output = T&amp;gt;&lt;/code&gt;traitを持っている制約をかけます。&lt;/p&gt;

&lt;p&gt;つまりコードは次のようになります。&lt;/p&gt;
use std::ops::Mul;

trait HasArea&lt;T&gt; {
    fn area(&amp;self) -&gt; T;
}

struct Square&lt;T&gt; {
    x: T,
    y: T,
    side: T,
}

impl&lt;T&gt; HasArea&lt;T&gt; for Square&lt;T&gt;
        where T: Mul&lt;Output = T&gt; + Copy {
    fn area(&amp;self) -&gt; T {
        self.side * self.side
    }
}

fn main() {
    let s = Square {
        x: 0.0f64,
        y: 0.0f64,
        side: 12.0f64,
    };

    println!(&#34;Area of s: {}&#34;, s.area());
}
</description>
    </item>
    
  </channel>
</rss>