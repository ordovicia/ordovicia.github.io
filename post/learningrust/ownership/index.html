<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.16-DEV" />

  <title>Learning Rust - Ownership &middot; 外部記憶</title>

  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/0.6.2/pure-min.css">

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/0.6.2/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/0.6.2/grids-responsive-min.css">
  <!--<![endif]-->

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="/css/side-menu-old-ie.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="/css/side-menu.css">
  <!--<![endif]-->

  <link rel="stylesheet" href="/css/blackburn.css">

  
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  
  <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">

  
  

  

  <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon" />

  
  

</head>


<body>
<div id="layout">

  
<a href="#menu" id="menuLink" class="menu-link">
  
  <span></span>
</a>
<div id="menu">

  

  <div class="pure-menu">
    <ul class="pure-menu-list">
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="/"><i class='fa fa-home fa-fw'></i>Home</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="/about/"><i class='fa fa-user fa-fw'></i>About</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="/post/"><i class='fa fa-list fa-fw'></i>Posts</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="/tags/"><i class='fa fa-tags fa-fw'></i>Tags</a>
      
        </li>
      
    </ul>
  </div>

  <div class="pure-menu social">
  <ul class="pure-menu-list">

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://twitter.com/ordovicia" target="_blank"><i class="fa fa-twitter-square fa-fw"></i>Twitter</a>
    </li>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://github.com/ordovicia" target="_blank"><i class="fa fa-github-square fa-fw"></i>GitHub</a>
    </li>
    

    

    

    

    

    

    

    

    

    

    

    

    

  </ul>
</div>


  <div>
  <div class="small-print">
    <small>&copy; 2017. All rights reserved.</small>
  </div>
  <div class="small-print">
    <small>Built with&nbsp;<a href="https://gohugo.io/" target="_blank">Hugo</a></small>
    <small>Theme&nbsp;<a href="https://github.com/yoshiharuyamashita/blackburn" target="_blank">Blackburn</a></small>
  </div>
</div>

</div>


  <div id="main">


<div class="header">
  <h1>Learning Rust - Ownership</h1>
  <h2></h2>
</div>
<div class="content">

  <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>03 Dec 2015</time>
  </div>

  

  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="/tags/programming">Programming</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="/tags/rust">Rust</a>
    
  </div>
  
  

</div>

  

<h1 id="syntax-and-semantics:98ce1841cead9b5af67fecc02a280dcb">Syntax and Semantics</h1>

<p>今回扱うのは、Rustのリソース管理システムであるownershipの概念です。</p>

<p>このシステムによる解析はすべてコンパイル時におこなわれ、
Rustの目標の一つであった&rdquo;Zero-cost abstraction&rdquo;を達成しているそうです。</p>

<p>公式ドキュメントでは、ownershipシステムは</p>

<ul>
<li>Ownership</li>
<li>References and Borrowing</li>
<li>Lifetimes</li>
</ul>

<p>の3つの章からなっています。
今回はそのうち最初の二つを取り上げます。
というのは、ownershipシステムが難しくて(と、ドキュメントに書いてあります)、
Lifetimesまではまだ理解できていないからです(半分くらいは英語力のせいですが)。</p>

<h2 id="ownership:98ce1841cead9b5af67fecc02a280dcb">Ownership</h2>

<p>variabe bindingsはownershipをもちます。
そしてvariable bindingsがスコープを抜けると、それがもっているデータは
メモリ上から破棄されます。</p>

<p>次の例では、vectorがヒープ上につくられ、
<code>v</code>というvariable bindingがそのownershipをもち、
<code>foo()</code>のスコープを抜けるとこのvectorに関するすべてのデータが削除されます。</p>
fn foo() {
    let v = vec![1, 2, 3];
}

<p>ヒープに確保されるんですね。驚きです。</p>

<h2 id="move-semantics:98ce1841cead9b5af67fecc02a280dcb">Move semantics</h2>

<p>Rustではメモリ上に確保されたひとつのデータのownershipをもつ
variable bindingはたったひとつだけです。
よって、例えばvectorを他のvectorに代入できますが、そのときmoveが起こります。</p>
let v = vec![1, 2, 3];
let v2 = v;

println!("v[0] is: {}", v[0]);

<p>このコードはコンパイルエラーになります。2行目で<code>v</code>が<code>v2</code>にmoveされて
vectorのownershipを失っているので、
<code>v[0]</code>という操作ができなくなっているのです。</p>

<p>関数に渡したときもmoveが起こり、下のコードもコンパイルエラーとなります。</p>
fn take(v: Vec<i32>) {
    // what happens here isn’t important.
}

let v = vec![1, 2, 3];
take(v);

println!("v[0] is: {}", v[0]);

<h2 id="the-details:98ce1841cead9b5af67fecc02a280dcb">The details</h2>

<p>Rustのメモリアロケーションがどのように働き、
なぜmoveが起こるのか、次のコードを題材に詳しく見ていきます。</p>
let v = vec![1, 2, 3];

let v2 = v;

<p>1行目では、vectorのメモリアロケーションが起こります。
vectorの要素(<code>[1, 2, 3]</code>)がヒープ上に確保され、
それを指すポインタがvectorオブジェクトとしてスタックに確保されます。
上で「vectorがヒープ上につくられる」といったのは、
詳しくはこういうことになります。</p>

<p>そして2行目では、<code>v</code>から<code>v2</code>へのmoveが起こります。
このとき、vectorオブジェクト<code>v</code>が持っているポインタが、<code>v2</code>にコピーされます。
するとヒープ上の同一データを指すポインタが二つ存在することになり、
これはdata raceの起こりえないことを保証する
Rustのシステムに反することになるため、 以降<code>v</code>をつかっていないことがコンパイル時に確かめられるようです。</p>

<h2 id="copy-types:98ce1841cead9b5af67fecc02a280dcb"><code>Copy</code> types</h2>

<p>vectorは代入でmoveが起こりましたが、下のコードはエラーになりません。</p>
let v = 1;
let v2 = v;

println!("v is: {}", v);

<p>これは、<code>v</code>の型である<code>i32</code>が<code>Copy</code>traitを持っているためです。
vectorとちがって<code>i32</code>は軽くポインタを利用していないので、
moveではなくdeep copyが起きる、ということのようです。</p>

<p><code>i32</code>や<code>bool</code>などの組み込み型はすべて<code>Copy</code>traitをもっています。
よって関数に渡したりほかのvariable bindingsに代入しても
moveは起こりません。</p>

<h2 id="more-than-ownership:98ce1841cead9b5af67fecc02a280dcb">More than ownership</h2>

<p>こんなコードを書けばコンパイルエラーは起こりません。</p>
fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {
    // do stuff with v1 and v2

    // hand back ownership, and the result of our function
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);

<p><code>foo()</code>に<code>v1, v2</code>のownershipを渡していますが、
<code>foo()</code>からまたownershipも返すようにしています。
ちゃんと動きます(Rustは同じ変数名を付けて、古いものを隠せるんでしたね)。</p>

<p>でも、ownershipを行ったり来たりさせるの面倒だし遅そうだし
やりたくないですよね。
ほかの現代的な言語とおなじように、Rustにもちゃんと解決策があります。</p>

<h1 id="references-and-borrowing:98ce1841cead9b5af67fecc02a280dcb">References and Borrowing</h1>

<h2 id="borrowing:98ce1841cead9b5af67fecc02a280dcb">Borrowing</h2>

<p>上のコードを次のように改善します。</p>
fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {
    // do stuff with v1 and v2

    // return the answer
    42
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let answer = foo(&v1, &v2);

<p>まず、<code>foo()</code>の引数の型<code>Vec&lt;i32&gt;</code>に<code>&amp;</code>をつけました。
さらに引数<code>v1, v2</code>にも<code>&amp;</code>をつけます。
こうすることで参照の受け渡しとなりました。</p>

<p>参照はメモリ上のデータのownershipをもつのではなく、借ります。
参照がスコープを抜けてもメモリの解放はおこなわれません。</p>

<h2 id="mut-references:98ce1841cead9b5af67fecc02a280dcb"><code>&amp;mut</code> references</h2>

<p>Rustはデフォルトでimmutableなので、上のように参照を定義しても、
それを通して書き換えることはできません。
書き換えたい場合は<code>&amp;mut Type</code>のように明示します。</p>
let mut x = 5;

{
    let y = &mut x;
    *y += 1;
}

println!("{}", x)

<p>このコードは&rsquo;6&rsquo;を出力します。
<code>{}</code>内で<code>&amp;mut</code>な参照<code>y</code>をつくり、<code>*y</code>で間接参照してインクリメントしました。
C++とおなじように、参照先は<code>*</code>でアクセスできます。</p>

<p>ここで一つ実験してみました。
次のコードは順に5, 5, 6, 6, 6を出力します。
出力部で<code>p</code>と<code>*p</code>がどっちも使えるのは、
<code>println!()</code>マクロのポリモーフィズムのおかげでしょうか？</p>
let mut q = 5;
let p = &mut q;

println!("{}", p);
println!("{}", *p);

*p += 1; // p += 1 はコンパイルエラー

println!("{}", p);
println!("{}", *p);
println!("{}", q)

<h2 id="the-rules:98ce1841cead9b5af67fecc02a280dcb">The Rules</h2>

<p>さて、上に挙げた</p>
let mut x = 5;

{
    let y = &mut x;
    *y += 1;
}

println!("{}", x)

<p>のコードは、<code>{}</code>でスコープをつくり、<code>y</code>を囲っていますね。
実はこの<code>{}</code>を取り除くと、コンパイルエラーになります。</p>

<p>なぜでしょう。ここで参照によるownershipの貸与について
規則が述べられていました。</p>

<ol>
<li>参照はその参照先が消えたあとにも存在していてはいけない</li>
<li>ある元データについて定義できる参照は次の二種類があるが、
両方同時にはつくれない

<ul>
<li>一つまたは複数のimmutableな参照(<code>&amp;T</code>)</li>
<li>一つのみのmutableな参照(<code>&amp;mut T</code>)</li>
</ul></li>
</ol>

<p>二つ目の規則は、data raceを防ぐ十分条件になっています。
同時にメモリ上の同じデータに複数のアクセスがあり、
そのうち一つ以上が書き込み操作のときdata raceが起こるのでした。</p>

<p><code>{}</code>を取り除くと、この二つ目に反することになります。
mutableな参照<code>y</code>が存在しているうちに、<code>println!()</code>においてまた<code>x</code>の
参照が作られようとするからです。</p>
let mut x = 5;

let y = &mut x;    // -+ &mut borrow of x starts here
*y += 1;           //  |
                   //  |
println!("{}", x); // -+ - try to borrow x here
                   // -+ &mut borrow of x ends here

<p>そこで<code>y</code>を<code>{}</code>で囲むと、参照の存在がconflictせず、
data raceがないことが保証できます。</p>

<h2 id="issues-borrowing-prevents:98ce1841cead9b5af67fecc02a280dcb">Issues borrowing prevents</h2>

<p>このようにRustは厳格(すぎる)リソース管理システムを持っています。
なぜこのような制限が必要なのか一度確認しておきましょう。</p>

<h3 id="use-after-free:98ce1841cead9b5af67fecc02a280dcb">Use after free</h3>

<p>まずはひとつ目の、参照が元データより長く存在してはいけないというルールです。</p>
let y: &i32;

{
    let x = 5;
    y = &x;
}

println!("{}", y);

<p>このコードは、<code>x</code>を参照する<code>y</code>が<code>x</code>より長く存在しているので違反となります。
参照先が不定になると再現性の無いバグとなって大変ですね。
Rustではこのようなスコープ解析がコンパイル時におこなわれます。</p>

<p>さらに次のコードもコンパイルエラーになります。</p>
let y: &i32;
let x = 5;
y = &x;

println!("{}", y);

<p>スコープは同じですが、<code>y</code>が<code>x</code>より先に定義されているため、
スコープを抜けるときは逆順に、
つまり<code>x</code>の次に<code>y</code>が削除されることになるからです。
スタックの下にあるものしか参照できないということでしょう。厳しいですね。</p>

<h3 id="iterator-invalidation:98ce1841cead9b5af67fecc02a280dcb">Iterator invalidation</h3>

<p>二つ目のルールを確認します。
次のコードはコンパイルエラーです。</p>
let mut v = vec![1, 2, 3];
v.push(42);

for i in &v {
    println!("{}", i);
    v.push(34);
}

<p>まず、一行目でvectorの<code>v</code>を<code>mut</code>として定義しました。
二行目では<code>push</code>を行うために、<code>v</code>のmutableな参照が一時的につくられ、
<code>push</code>後すぐに破棄されるようです。</p>

<p>そのあとの<code>for</code>ループで、immutableな参照として<code>v</code>の
ownershipを借りています。
そのループ内で<code>v</code>に対して<code>push</code>しようとすると、さらに<code>v</code>のmutableな参照を
得ることになります。
これは、mutableな参照を一つ作ると、その他に(mutable,
immutableにかかわらず)参照が作れないというルールに反していますね。</p>

<hr />

<p>今回はここまでです。
次回はLifetimesを扱うつもりですが、一読してもさっぱりだったので、
まだ時間がかかりそうです。</p>


  
<div class="prev-next-post pure-g">
  <div class="pure-u-1-24" style="text-align: left;">
    
    <a href="/post/learningrust/if_and_loops/"><i class="fa fa-chevron-left"></i></a>
    
  </div>
  <div class="pure-u-10-24">
    
    <nav class="prev">
      <a href="/post/learningrust/if_and_loops/">Learning Rust - If and Loops</a>
    </nav>
    
  </div>
  <div class="pure-u-2-24">
    &nbsp;
  </div>
  <div class="pure-u-10-24">
    
    <nav class="next">
      <a href="/post/archlinuxonraspi/initial_setup/">Arch Linux on Raspberry Pi 2 - 初期セットアップ</a>
    </nav>
    
  </div>
  <div class="pure-u-1-24" style="text-align: right;">
    
    <a href="/post/archlinuxonraspi/initial_setup/"><i class="fa fa-chevron-right"></i></a>
    
  </div>
</div>



  

</div>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] }
  });
</script>
<script
    type="text/javascript"
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" />
</script>

