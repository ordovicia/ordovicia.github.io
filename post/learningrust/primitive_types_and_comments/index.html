<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.16-DEV" />

  <title>Learning Rust - Primitive Types and Comments &middot; 外部記憶</title>

  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/0.6.2/pure-min.css">

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/0.6.2/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/0.6.2/grids-responsive-min.css">
  <!--<![endif]-->

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="/css/side-menu-old-ie.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="/css/side-menu.css">
  <!--<![endif]-->

  <link rel="stylesheet" href="/css/blackburn.css">

  
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  
  <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">

  
  

  

  <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon" />

  
  

</head>


<body>
<div id="layout">

  
<a href="#menu" id="menuLink" class="menu-link">
  
  <span></span>
</a>
<div id="menu">

  

  <div class="pure-menu">
    <ul class="pure-menu-list">
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="/"><i class='fa fa-home fa-fw'></i>Home</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="/about/"><i class='fa fa-user fa-fw'></i>About</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="/post/"><i class='fa fa-list fa-fw'></i>Posts</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="/tags/"><i class='fa fa-tags fa-fw'></i>Tags</a>
      
        </li>
      
    </ul>
  </div>

  <div class="pure-menu social">
  <ul class="pure-menu-list">

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://twitter.com/ordovicia" target="_blank"><i class="fa fa-twitter-square fa-fw"></i>Twitter</a>
    </li>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://github.com/ordovicia" target="_blank"><i class="fa fa-github-square fa-fw"></i>GitHub</a>
    </li>
    

    

    

    

    

    

    

    

    

    

    

    

    

  </ul>
</div>


  <div>
  <div class="small-print">
    <small>&copy; 2017. All rights reserved.</small>
  </div>
  <div class="small-print">
    <small>Built with&nbsp;<a href="https://gohugo.io/" target="_blank">Hugo</a></small>
    <small>Theme&nbsp;<a href="https://github.com/yoshiharuyamashita/blackburn" target="_blank">Blackburn</a></small>
  </div>
</div>

</div>


  <div id="main">


<div class="header">
  <h1>Learning Rust - Primitive Types and Comments</h1>
  <h2></h2>
</div>
<div class="content">

  <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>12 Nov 2015</time>
  </div>

  

  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="/tags/programming">Programming</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="/tags/rust">Rust</a>
    
  </div>
  
  

</div>

  

<h1 id="syntax-and-semantics:fa1278f2e63f3d5784daac7062652a62">Syntax and Semantics</h1>

<p>前々回につづけて、
<a href="https://doc.rust-lang.org/book/syntax-and-semantics.html">syntaxとsemanticsのドキュメント</a>
を読んでいきます。</p>

<h2 id="primitive-types:fa1278f2e63f3d5784daac7062652a62">Primitive Types</h2>

<p>組み込み型の紹介です。
よくある型に加えて、Rustでは<code>Slice</code>や<code>Tuple</code>もprimitiveです。</p>

<h3 id="boolean:fa1278f2e63f3d5784daac7062652a62">Boolean</h3>

<p><code>bool</code>ですね。<code>true</code>または<code>false</code>の値があります。</p>

<h3 id="char:fa1278f2e63f3d5784daac7062652a62"><code>char</code></h3>

<p>文字一つをあらわします。
中身は4byteのUnicodeスカラ値で、</p>
let two_hearts = '💕';

<p>のようなこともできるそうです。</p>

<h3 id="numeric-types:fa1278f2e63f3d5784daac7062652a62">Numeric types</h3>

<p>数値型です。まず列挙すると、</p>

<ul>
<li><code>i8</code></li>
<li><code>i16</code></li>
<li><code>i32</code></li>
<li><code>i64</code></li>
<li><code>u8</code></li>
<li><code>u16</code></li>
<li><code>u32</code></li>
<li><code>u64</code></li>
<li><code>isize</code></li>
<li><code>usize</code></li>
<li><code>f32</code></li>
<li><code>f64</code></li>
</ul>

<p>があります。
<code>i, u, f</code>のprefixが種類を表し、それぞれ符号付き整数、符号なし整数、浮動小数点となっているようです。
そして数値がサイズを表しています。
例えば<code>i32</code>は符号付き32btit整数で、<code>u64</code>は符号なし64bit整数です。
整数型にサイズが決まっているのは移植性が高くて好印象です。</p>

<p>Rustの型推論では、整数リテラルは<code>i32</code>、小数リテラルは<code>f64</code>と推定されるそうです。</p>

<p><code>isize, usize</code>が気になります。
これは実行マシンのアドレスとおなじサイズをもつ整数型だそうです。</p>

<h3 id="arrays:fa1278f2e63f3d5784daac7062652a62">Arrays</h3>

<p>配列もあります。型は<code>[Type; Size]</code>と表します。例えば以下です。</p>
let ary = [1, 2, 3]; // a: [i32; 3]

<p>ジェネリクスによって、<code>Type</code>にはいろんな型がはいります。
要素数である<code>Size</code>はコンパイル時定数である必要があるそうです。</p>

<p>すべての要素に同じ値を代入して初期化することもできます。
例えば次のようにすると<code>ary</code>は20要素をもち、すべて0で初期化されます。</p>
let ary = [0; 20]; // a: [i32; 20]

<p>要素数を得るには<code>ary.len()</code>のように<code>len()</code>関数をつかい、
各要素にアクセスするには<code>ary[0]</code>のようにします。indexは0-basedです。</p>
let names = ["Graydon", "Brian", "Niko"]; // names: [&str; 3]
println!("There are {} names. The second name is: {}", names.len(), names[1]);

<p>要素アクセスの際、indexが有効かどうかは実行時にチェックされます。
範囲外参照をしていた場合、実行時エラーとなります。</p>

<h3 id="slices:fa1278f2e63f3d5784daac7062652a62">Slices</h3>

<p><code>Slice</code>は連続して配置されているデータ構造への参照です。
内部にポインタと長さをもっているようです。</p>
let a = [0, 1, 2, 3, 4];
let middle = &a[1..4]; // 1, 2, and 3
let complete = &a[..]; // all of the elements in a
let str_slice: &[&str] = &["one", "two", "three"];

<p><code>&amp;array[begin..end]</code>のように書くようですね。
範囲は[begin, end)になります。
また、<code>&amp;array[..]</code>と書くとすべての要素をとります。</p>

<p>vectorにも使えます。</p>
let vec = vec![1, 2, 3];
let int_slice = &vec[..];

<p>参照先はmutableにすることもでき、型を<code>&amp;mut [T]</code>と表します。</p>
let xs: &mut [i32] = &mut [1, 2, 3];
xs[1] = 7;

<h3 id="str:fa1278f2e63f3d5784daac7062652a62"><code>str</code></h3>

<p>Rustの文字列はなんだか特殊なようです。
ドキュメントを引用すると、</p>

<blockquote>
<p>Rust’s str type is the most primitive string type. As an unsized type, it’s not very useful by itself, but becomes useful when placed behind a reference, like &amp;str.</p>
</blockquote>

<p>とあります。ほとんどの場合は参照、つまり<code>&amp;str</code>のかたちで使うようですね。
もっと詳しいリファレンスを読んでもいいのですが、まだ知らない概念がいくつも登場してきたので深追いはやめておきます。</p>

<h3 id="tuples:fa1278f2e63f3d5784daac7062652a62">Tuples</h3>

<p><code>Tuple</code>は型の直積です。<code>(Type0, Type1, .., TypeN)</code>と表します。</p>
let mut x: (i32, &str) = (1, "hello");
let y = (2, "world");
x = y;

<p>次のように書くと各要素に名前をつけることができます。</p>
let (x, y, z) = (1, 2, 3);
println!("x is {}", x);

<p>let statementにはpatternが渡せるのでしたね。</p>

<p>でも、この例は<code>Tuple</code>の型といえるのでしょうか？
<code>(x, y, z)</code>は<code>Tuple</code>として作られているのでしょうか？</p>

<p>サイズが一つだけの<code>Tuple</code>には注意が必要です。
<code>(0)</code>はただ0をかっこで囲んだだけです。
<code>Tuple</code>にするには、<code>(0,)</code>のようにコンマ<code>,</code>が必要になります。
ちょっと気持ち悪い記法ですが、仕方ないのでしょう。</p>

<h4 id="tuple-indexing:fa1278f2e63f3d5784daac7062652a62">Tuple indexing</h4>

<p><code>Tuple</code>の各要素にアクセスするには、</p>
let tuple = (1, 2, 3);

let x = tuple.0;
let y = tuple.1;
let z = tuple.2;

println!("x is {}", x);

<p>のように、ドット<code>.</code>に続けてindexを数値で書きます。
配列の<code>[]</code>とは違うようです。</p>

<h3 id="functions:fa1278f2e63f3d5784daac7062652a62">Functions</h3>

<p>関数も型を持ちます。
<a href="http://hadeaneon.hatenablog.com/entry/2015/11/09/081819">Function Pointer</a>
の節で扱ったとおりです。</p>
fn add_one(x: i32) -> i32 {
    x + 1
}

let x: fn(i32) -> i32 = foo;

<h2 id="comments:fa1278f2e63f3d5784daac7062652a62">Comments</h2>

<p>C++と同じように、<code>//</code>を書くと、そこから行末までがコメントになります。
また、<code>/* */</code>によるブロックコメントもあります。
<code>/* */</code>は入れ子にすることもできるようです。
うれしいですね。</p>

<p>また、Rustには&rsquo;doc comments&rsquo;というものがあります。
例えば、</p>
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let five = 5;
///
/// assert_eq!(6, add_one(5));
/// # fn add_one(x: i32) -> i32 {
/// #     x + 1
/// # }
/// ```
fn add_one(x: i32) -> i32 {
    x + 1
}

<p>のように<code>///</code>を書くと、それに続くコード片のドキュメントになります。
また、<code>//!</code>と書くと、続くコード片ではなくそのファイルの内容に対するドキュメントになるようです。
doc commentsにはMarkdown記法がつかえ、<code>rustdoc</code>というツールでHTMLに変換できるそうです。
しかもdoc commentsに書いたコード例を実行することもできるそうです。
これは便利ですね。</p>

<p>ところで、上のdoc commentsには<code>assert_eq!()</code>が登場しています。
予想できる通り、このmacroは二つの引数が等しいかチェックして、等しくなければその場で<code>panic!()</code>します。
また引数が<code>true</code>かチェックする<code>assert!()</code>ももちろんあります。</p>

<hr />

<p>キリがいいので今回はここまでです。
次回のRustは条件分岐とループを扱います。</p>


  
<div class="prev-next-post pure-g">
  <div class="pure-u-1-24" style="text-align: left;">
    
    <a href="/post/learningrust/dining_philosophers/"><i class="fa fa-chevron-left"></i></a>
    
  </div>
  <div class="pure-u-10-24">
    
    <nav class="prev">
      <a href="/post/learningrust/dining_philosophers/">Learning Rust - Dining Philosophers</a>
    </nav>
    
  </div>
  <div class="pure-u-2-24">
    &nbsp;
  </div>
  <div class="pure-u-10-24">
    
    <nav class="next">
      <a href="/post/learningrust/if_and_loops/">Learning Rust - If and Loops</a>
    </nav>
    
  </div>
  <div class="pure-u-1-24" style="text-align: right;">
    
    <a href="/post/learningrust/if_and_loops/"><i class="fa fa-chevron-right"></i></a>
    
  </div>
</div>



  

</div>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] }
  });
</script>
<script
    type="text/javascript"
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" />
</script>

